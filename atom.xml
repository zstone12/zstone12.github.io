<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Stone&#39;s Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-05-14T14:01:06.563Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>zstone12</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>问题复盘</title>
    <link href="http://example.com/2021/11/26/%E9%97%AE%E9%A2%98%E5%A4%8D%E7%9B%98/"/>
    <id>http://example.com/2021/11/26/%E9%97%AE%E9%A2%98%E5%A4%8D%E7%9B%98/</id>
    <published>2021-11-26T14:41:41.000Z</published>
    <updated>2023-05-14T14:01:06.563Z</updated>
    
    <content type="html"><![CDATA[<p>一共出现了三个问题：</p><p>1.测试代码带到上线了</p><p>2.showcase的时候都没把主流程跑通。最后靠zhachen救场。</p><p>​    没有在本地把环境搭起来。导致debug的效率非常低。</p><ul><li>单元测试覆盖非常重要，写单元测试的确很花费时间，但是写好之后，单元测试可以每次都跑，节约了人肉测试的时间</li></ul><p>3.忘了</p><hr><p>太相信QA了…</p><hr><p>进行反思</p><p><strong>也不要完全相信QA。</strong></p><p>给自己一次失败的机会，但是下次要做好。这次只能是幸运、真的要算就是三次事故。</p><ul><li><p>一定要把思维训练的更加严谨，我认为这对我个人的长远发展是有好处的，开发之前，一定要想的比较清楚了，再开始，这样可以进一步减少后续的错误</p></li><li><p>单元测试覆盖非常重要，写单元测试的确很花费时间，但是写好之后，单元测试可以每次都跑，节约了人肉测试的时间</p></li><li><p>review这个流程非常重要，但是本次由于单个PR太大，review并没有发挥作用（review的也不够细致）</p></li><li><p>即使有review，也不能依赖review。还是要对自己的产出质量有要求，这是我对自己新的五年的一个要求</p></li><li><p>改动之后，一定要自己先完整的测试几遍，对于不熟悉的部分，一定要找老员工问清楚</p></li><li><p>对于大的改动，应当是先写好单元测试，然后再开始改动，这样就更容易知道哪里改错了</p></li></ul><hr><p>这次一定要先把主流程跑通。同时完善单测。</p><p>好消息是。我用很小的代价，得到了很大的教训。</p><p><strong>此后的每一个改动， 我都有加上单元测试，以及人肉去回归一遍。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一共出现了三个问题：&lt;/p&gt;
&lt;p&gt;1.测试代码带到上线了&lt;/p&gt;
&lt;p&gt;2.showcase的时候都没把主流程跑通。最后靠zhachen救场。&lt;/p&gt;
&lt;p&gt;​    没有在本地把环境搭起来。导致debug的效率非常低。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单元测试覆盖非常重要，写</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>BPF原理及应用</title>
    <link href="http://example.com/2021/04/12/BPF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    <id>http://example.com/2021/04/12/BPF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/</id>
    <published>2021-04-12T03:07:14.000Z</published>
    <updated>2023-05-14T13:50:41.557Z</updated>
    
    <content type="html"><![CDATA[<p>本文基本上是对 PingCAP wenbo zhang  <a href="https://www.bilibili.com/video/BV1B4411S7PP">Infra Meetup  No.111</a> 的笔记，还有对<code>bcc</code>的一些学习整理。</p><a id="more"></a> <p>BPF原理及应用这是一个很大的话题。但是再大的话题也能分割成一个个小话题。这段时间一直在折腾BPF相关的东西，却有些像盲人摸象，摸到哪里算哪。故而写一篇文章来总结一下。</p><p>Ok, 3..2..1..Let’s do it.</p><hr><p>先从 <code>tracing</code> 这个场景开始讲。</p><h2 id="1-Kernel-tracing"><a href="#1-Kernel-tracing" class="headerlink" title="1. Kernel tracing"></a>1. Kernel tracing</h2><h3 id="1-0-介绍"><a href="#1-0-介绍" class="headerlink" title="1.0 介绍"></a>1.0 介绍</h3><ul><li>Static tracing -&gt; Tracepoint（event trace）</li><li>Dynamic tracing -&gt; kprobe</li></ul><p>kernel tracing主要分为Static  tracing 和动态 Dynamic tracing</p><p>Static  tracing:  相当于对程序里面自己去写一些trace log，随着代码的编译 ，编译到代码里边。</p><p>Dynamic tracing :程序在运行的过程当中。可以在不打断程序的运行，可以对它某一个指令进行追踪。</p><h3 id="1-1-静态-tracing"><a href="#1-1-静态-tracing" class="headerlink" title="1.1 静态 tracing"></a>1.1 静态 tracing</h3><p>​    看一个静态追踪的例子:</p><p><code>perf tools</code> 就是基于静态 trace 实现的。</p><p><img src="https://raw.githubusercontent.com/brendangregg/perf-tools/master/images/perf-tools_2016.png" alt="img"></p><p>看一下<code>perf tools</code>中的<code>execsnoop</code></p><p><code>execsnoop</code>: trace process exec() with command line argument details.</p><p><code>execsnoop</code>实现上是对linux调度器子系统的一些trace，以及对exec()这个系统调用的一些trace.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> --depth 1 https://github.com/brendangregg/perf-tools</span><br><span class="line">$ <span class="built_in">cd</span> perf-tools/</span><br><span class="line">$ ./execsnoop</span><br></pre></td></tr></table></figure><p>可以得到下面的结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">➜  perf-tools git:(master) ./execsnoop</span><br><span class="line">Tracing <span class="built_in">exec</span>()s. Ctrl-C to end.</span><br><span class="line">Instrumenting sys_execve</span><br><span class="line">   PID   PPID ARGS</span><br><span class="line">  3049      0 mawk -W interactive -v o=1 -v opt_name=0 -v name= [...]</span><br><span class="line">  3050      0 cat -v trace_pipe</span><br><span class="line">  3051      0 /bin/sh -c ls -l /proc/[0-9]*/fd/[0-9]* | grep socket:</span><br><span class="line">  3053      0 grep socket:</span><br><span class="line">  3052      0 ls -l /proc/1/fd/0 /proc/1/fd/1 /proc/1/fd/10 /proc/1/fd/11 /proc/1/fd/12 /proc/1/fd/13 /proc/1/fd/14 [...]</span><br><span class="line">  3054      0 /bin/sh -c ls -l /proc/[0-9]*/fd/[0-9]* | grep socket:</span><br><span class="line">  3056      0 grep socket:</span><br><span class="line">  3055      0 ls -l /proc/1/fd/0 /proc/1/fd/1 /proc/1/fd/10 /proc/1/fd/11 /proc/1/fd/12 /proc/1/fd/13 /proc/1/fd/14 [...]</span><br><span class="line">  3057      0 /bin/sh -c ls -l /proc/[0-9]*/fd/[0-9]* | grep socket:</span><br><span class="line">  3059      0 grep socket:</span><br><span class="line">  3058      0 ls -l /proc/1/fd/0 /proc/1/fd/1 /proc/1/fd/10 /proc/1/fd/11 /proc/1/fd/12 /proc/1/fd/13 /proc/1/fd/14 [...]</span><br><span class="line">^C</span><br><span class="line">Ending tracing...</span><br></pre></td></tr></table></figure><p>execsnoop的部分代码如下。可以看到和下面的 ftrace 例子有相似之处</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### setup and begin tracing</span></span><br><span class="line"><span class="built_in">echo</span> nop &gt; current_tracer</span><br><span class="line"><span class="keyword">if</span> ! <span class="built_in">echo</span> <span class="variable">$kprobe</span> &gt;&gt; kprobe_events 2&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">makeprobe stub_execve</span><br><span class="line"><span class="keyword">if</span> ! <span class="built_in">echo</span> <span class="variable">$kprobe</span> &gt;&gt; kprobe_events 2&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">    makeprobe do_execve</span><br><span class="line">    <span class="keyword">if</span> ! <span class="built_in">echo</span> <span class="variable">$kprobe</span> &gt;&gt; kprobe_events 2&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">    edie <span class="string">&quot;ERROR: adding a kprobe for execve. Exiting.&quot;</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> ! <span class="built_in">echo</span> 1 &gt; events/kprobes/<span class="variable">$kname</span>/<span class="built_in">enable</span>; <span class="keyword">then</span></span><br><span class="line">edie <span class="string">&quot;ERROR: enabling kprobe for execve. Exiting.&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> ! <span class="built_in">echo</span> 1 &gt; events/<span class="built_in">sched</span>/sched_process_fork/<span class="built_in">enable</span>; <span class="keyword">then</span></span><br><span class="line">edie <span class="string">&quot;ERROR: enabling sched:sched_process_fork tracepoint. Exiting.&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>而perf-tools 具体是基于 <code>ftrace</code> 实现的脚本 ，顺着思路去了解 <code>ftrace</code>.  </p><h3 id="1-2-ftrace"><a href="#1-2-ftrace" class="headerlink" title="1.2 ftrace"></a>1.2 ftrace</h3><h4 id="1-2-1-定义"><a href="#1-2-1-定义" class="headerlink" title="1.2.1 定义"></a>1.2.1 定义</h4><p>Ftrace is an internal tracer designed to help out developers and designers of systems to fifind what is going on inside the kernel.</p><p>It can be used for debugging or analyzing latencies and performance issues that take place outside of user-space.</p><blockquote><p>大概就是一个 trace 工具…</p></blockquote><p>原来的<code>ftrace</code> 只是一个<code>funtion trace</code> ,</p><p>现在发展为一个框架，包含<code>plugins</code> <code>events</code>这两个方式。</p><hr><h4 id="1-2-2-ftrace-plugins"><a href="#1-2-2-ftrace-plugins" class="headerlink" title="1.2.2 ftrace plugins"></a>1.2.2 ftrace plugins</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">4096</span>];</span><br><span class="line">sleep(<span class="number">30</span>);</span><br><span class="line"><span class="keyword">int</span> fd = open(<span class="string">&quot;./test.c&quot;</span>,O_RDONLY);</span><br><span class="line">read(fd,buf,<span class="number">4096</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># ftrace_test.sh</span></span><br><span class="line">debugfs=/sys/kernel/debug</span><br><span class="line"><span class="built_in">echo</span> nop &gt; <span class="variable">$debugfs</span>/tracing/current_tracer</span><br><span class="line"><span class="built_in">echo</span> 0 &gt; <span class="variable">$debugfs</span>/tracing/tracing_on</span><br><span class="line"><span class="built_in">echo</span> `pidof <span class="built_in">read</span>` &gt; <span class="variable">$debugfs</span>/tracing/set_ftrace_pid</span><br><span class="line"><span class="built_in">echo</span> function_graph &gt; <span class="variable">$debugfs</span>/tracing/current_tracer</span><br><span class="line"><span class="built_in">echo</span> vfs_read &gt; <span class="variable">$debugfs</span>/tracing/set_graph_function</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; <span class="variable">$debugfs</span>/tracing/tracing_on</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc 1.c -o <span class="built_in">read</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./<span class="built_in">read</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 同时在另一个终端</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./ftrace_test.sh</span></span><br></pre></td></tr></table></figure><p>然后<code>cat /sys/kernel/debug/tracing/trace</code>查看结果如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"># tracer: function_graph</span><br><span class="line">#</span><br><span class="line"># CPU  DURATION                  FUNCTION CALLS</span><br><span class="line"># |     |   |                     |   |   |   |</span><br><span class="line"> 0)               |  vfs_read() &#123;</span><br><span class="line"> 0)               |    rw_verify_area() &#123;</span><br><span class="line"> 0)               |      security_file_permission() &#123;</span><br><span class="line"> 0)               |        apparmor_file_permission() &#123;</span><br><span class="line"> 0)               |          common_file_perm() &#123;</span><br><span class="line"> 0)   0.327 us    |            aa_file_perm();</span><br><span class="line"> 0)   1.756 us    |          &#125;</span><br><span class="line"> 0)   2.787 us    |        &#125;</span><br><span class="line"> 0)               |        __fsnotify_parent() &#123;</span><br><span class="line"> 0)   0.327 us    |          dget_parent();</span><br><span class="line"> 0)               |          dput() &#123;</span><br><span class="line"> 0)               |            dput.part.26() &#123;</span><br><span class="line"> 0)               |              _cond_resched() &#123;</span><br><span class="line"> 0)   0.297 us    |                rcu_all_qs();</span><br><span class="line"> 0)   0.982 us    |              &#125;</span><br><span class="line"> 0)   1.724 us    |            &#125;</span><br><span class="line"> 0)   2.372 us    |          &#125;</span><br><span class="line"> 0)   3.800 us    |        &#125;</span><br><span class="line"> 0)   0.311 us    |        fsnotify();</span><br><span class="line"> 0)   8.335 us    |      &#125;</span><br><span class="line"> 0)   9.229 us    |    &#125;</span><br><span class="line"> 0)               |    __vfs_read() &#123;</span><br><span class="line"> 0)               |      new_sync_read() &#123;</span><br><span class="line"> 0)               |        ext4_file_read_iter() &#123;</span><br><span class="line"> 0)               |          generic_file_read_iter() &#123;</span><br><span class="line"> 0)               |            _cond_resched() &#123;</span><br><span class="line"> 0)   0.291 us    |              rcu_all_qs();</span><br><span class="line"> 0)   0.847 us    |            &#125;</span><br><span class="line"> 0)               |            pagecache_get_page() &#123;</span><br><span class="line"> 0)   0.593 us    |              find_get_entry();</span><br><span class="line"> 0)   1.227 us    |            &#125;</span><br><span class="line"> 0)   0.468 us    |            mark_page_accessed();</span><br><span class="line"> 0)               |            _cond_resched() &#123;</span><br><span class="line"> 0)   0.275 us    |              rcu_all_qs();</span><br><span class="line"> 0)   0.823 us    |            &#125;</span><br><span class="line"> 0)               |            _cond_resched() &#123;</span><br><span class="line"> 0)   0.235 us    |              rcu_all_qs();</span><br><span class="line"> 0)   1.009 us    |            &#125;</span><br><span class="line"> 0)               |            pagecache_get_page() &#123;</span><br><span class="line"> 0)   0.192 us    |              find_get_entry();</span><br><span class="line"> 0)   0.622 us    |            &#125;</span><br><span class="line"> 0)               |            touch_atime() &#123;</span><br><span class="line"> 0)               |              __atime_needs_update() &#123;</span><br><span class="line"> 0)               |                current_time() &#123;</span><br><span class="line"> 0)   0.300 us    |                  current_kernel_time64();</span><br><span class="line"> 0)   0.184 us    |                  timespec_trunc();</span><br><span class="line"> 0)   1.126 us    |                &#125;</span><br><span class="line"> 0)   1.709 us    |              &#125;</span><br><span class="line"> 0)   2.163 us    |            &#125;</span><br><span class="line"> 0) + 11.661 us   |          &#125;</span><br><span class="line"> 0) + 12.257 us   |        &#125;</span><br><span class="line"> 0) + 13.031 us   |      &#125;</span><br><span class="line"> 0) + 13.630 us   |    &#125;</span><br><span class="line"> 0)               |    __fsnotify_parent() &#123;</span><br><span class="line"> 0)   0.180 us    |      dget_parent();</span><br><span class="line"> 0)               |      dput() &#123;</span><br><span class="line"> 0)               |        dput.part.26() &#123;</span><br><span class="line"> 0)               |          _cond_resched() &#123;</span><br><span class="line"> 0)   0.178 us    |            rcu_all_qs();</span><br><span class="line"> 0)   0.529 us    |          &#125;</span><br><span class="line"> 0)   0.882 us    |        &#125;</span><br><span class="line"> 0)   1.228 us    |      &#125;</span><br><span class="line"> 0)   1.953 us    |    &#125;</span><br><span class="line"> 0)   0.182 us    |    fsnotify();</span><br><span class="line"> 0) + 29.688 us   |  &#125;</span><br></pre></td></tr></table></figure><p>这样就可以查看刚才这个C代码中<code>vfs_read</code>的相关调用流程。</p><hr><h4 id="1-2-3-ftrace-events"><a href="#1-2-3-ftrace-events" class="headerlink" title="1.2.3 ftrace events"></a>1.2.3 ftrace events</h4><p>在<code>/sys/kernel/debug/tracing/events</code>目录下可以看到可以<code>trace</code>的事件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">➜  events ls</span><br><span class="line">alarmtimer  filemap       mce             ras           thermal</span><br><span class="line">block       fs            mdio            raw_syscalls  thermal_power_allocator</span><br><span class="line">bpf         fs_dax        migrate         rcu           timer</span><br><span class="line">bridge      ftrace        mmc             regmap        tlb</span><br><span class="line">btrfs       gpio          module          regulator     udp</span><br><span class="line">cgroup      header_event  mpx             rpm           vmscan</span><br><span class="line">clk         header_page   msr             <span class="built_in">sched</span>         vsyscall</span><br><span class="line">cma         huge_memory   napi            scsi          wbt</span><br><span class="line">compaction  hyperv        net             signal        workqueue</span><br><span class="line">cpuhp       i2c           nmi             skb           writeback</span><br><span class="line">dma_fence   iommu         oom             smbus         x86_fpu</span><br><span class="line">drm         irq           page_isolation  sock          xdp</span><br><span class="line"><span class="built_in">enable</span>      irq_matrix    pagemap         spi           xen</span><br><span class="line">exceptions  irq_vectors   percpu          swiotlb       xfs</span><br><span class="line">ext4        jbd2          power           sync_trace    xhci-hcd</span><br><span class="line">fib         kmem          printk          syscalls</span><br><span class="line">fib6        kprobes       qdisc           task</span><br><span class="line">filelock    libata        random          tcp</span><br></pre></td></tr></table></figure><p>events的样例 可以看PingCAP 的<a href="https://github.com/pingcap/tidb-inspect-tools/blob/master/tracing_tools/ftrace/mem/drsnoop">Drsnoop</a></p><hr><h4 id="1-2-4-Plugins-and-events"><a href="#1-2-4-Plugins-and-events" class="headerlink" title="1.2.4 Plugins and events"></a>1.2.4 Plugins and events</h4><p>plugins</p><p>● list in avaliable_tracers</p><p>● set via current_tracer</p><p>● only one at a time</p><blockquote><p>avaliable_tracers 目前我们只关注funtion 和 funciton_graph</p></blockquote><p>events</p><p>● list in avaliable_events</p><p>● set via set_event</p><p>● any number of events can be enable</p><hr><h4 id="1-2-5-ftrace-的限制"><a href="#1-2-5-ftrace-的限制" class="headerlink" title="1.2.5 ftrace 的限制"></a>1.2.5 ftrace 的限制</h4><p>● Default, all events share a global ring buffer</p><p>● trace_pipe is globally shared, so concurrent</p><p>programs will have clashing output</p><p>● Not programmable</p><p>● Predefifined</p><p>● Max fifilter expression’s size &lt; 4096( one  page)</p><blockquote><p>我觉得最关键的是不可编程。这也就是BPF 存在的意义之一。</p></blockquote><hr><h4 id="1-2-6-trace-cmd"><a href="#1-2-6-trace-cmd" class="headerlink" title="1.2.6 trace-cmd"></a>1.2.6 trace-cmd</h4><p>对 ftrace 进行了一层封装的CLI工具，也称为trace 的frontend，简单好用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install -y trace-cmd</span><br><span class="line">$ sudo trace-cmd record -p function_graph -P 12089 -e     </span><br><span class="line">$ sudo trace-cmd report </span><br></pre></td></tr></table></figure><blockquote><p>大家可以执行一下。</p></blockquote><hr><h3 id="1-3-动态-tracing"><a href="#1-3-动态-tracing" class="headerlink" title="1.3 动态 tracing"></a>1.3 动态 tracing</h3><p><strong>kprobe</strong></p><h4 id="1-3-1Definition"><a href="#1-3-1Definition" class="headerlink" title="1.3.1Definition"></a>1.3.1Definition</h4><p>Kprobe enables you to dynamically break into any kernel routine and collect debugging and performance information non-disruptively. You can trap at almost any kernel code address, specifying a  handler routine to be invoked when the breakpoint is hit.</p><blockquote><p>kprobe 几乎可以对内核中每一条指令进行打断。实际上是做的一个指令(代码)替换，执行到某一条被替换的指令会触发异常。内核会判断是gdb引发的异常还是kprobe引发的异常。如果是kprobe引发的异常，会把正常的指令替换回来，然后去调用已注册的回调函数。</p></blockquote><p>有些和kprobe相关的函数不能trace, 定义在<code>/sys/kernel/debug/kprobes/blacklist</code></p><hr><h4 id="1-3-2-kprobe-jprobe-uprobe"><a href="#1-3-2-kprobe-jprobe-uprobe" class="headerlink" title="1.3.2 kprobe jprobe uprobe"></a>1.3.2 kprobe jprobe uprobe</h4><p>● A kprobe can be inserted on virtually any instruction in the kernel. </p><p>● A jprobe is inserted at the entry to a kernel function, and provides convenient access to the function’s arguments. </p><p>● A return probe fifires when a specifified function returns.</p><blockquote><p>rprobe 和jprobe 是基于kprobe的封装，简化了一些工作。</p><p>jprobe 只能放在函数的开始  </p><p>rprobe 只能放在函数的返回阶段</p><p>但是我目前在bcc 中是直接使用kprobe 和kretprobe .估计做了一层封装</p></blockquote><h4 id="1-3-3-biosnoop"><a href="#1-3-3-biosnoop" class="headerlink" title="1.3.3 biosnoop"></a>1.3.3 biosnoop</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blk_account_io_start</span><span class="params">(struct request *rq, <span class="keyword">bool</span> new_io)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blk_start_request</span><span class="params">(struct request *req)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blk_mq_start_request</span><span class="params">(struct request *rq)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blk_account_io_done</span><span class="params">(struct request *req)</span> </span></span><br><span class="line"><span class="function">  </span></span><br></pre></td></tr></table></figure><blockquote><p> 前三个函数是IO开始<br>第四个函数则是IO结束<br>blk_account_io_start包含在IO等待队列的时间<br>blk_start_request 是老的block设备<br>blk_mq_start_request 新的SSD设备 支持多队列的设备</p></blockquote><p><code>blktrace</code></p><hr><p>perf_events</p><p><img src="http://www.brendangregg.com/perf_events/perf_events_map.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比ftrace events 多了CPU相关</span><br></pre></td></tr></table></figure><p>front-end</p><p><code>perf</code> </p><hr><p>所以一个问题。已经有了这些这么好的工具。为什么还需要BPF？</p><blockquote><p>BPF整合了kprobe 和 tracepoint 从我的视角来说。或者说一个上层的使用者来说。</p></blockquote><hr><p><strong>BPF characteristic</strong></p><p>● User-defifined callback functions and data  processing can run directly in kernel space</p><p>● The user’s callback function impl is dyn executed, doesn’t participate in the compilation of the kernel, just like scripts</p><p>● Provide a unifified tracing framework for users</p><p>● BPF programs never crash kernel</p><p>● In addition, can do high-performance network processing or sandbox</p><blockquote><p>1.解决了数据拷贝问题。</p><p>2.用户态的回调函数是动态执行的，不需要参与内核的编译。</p><p>3.提高了一个统一的框架，可以用kprobe,可以用ftrace 。通过调用不同的helper函数就可以和不同的子系统打交道。</p><p>4.不会导致内核挂掉。</p></blockquote><hr><p>BPF tools</p><p><img src="https://github.com/iovisor/bcc/raw/master/images/bcc_tracing_tools_2019.png" alt="img"></p><blockquote><p>对比 perf_tools 和perf_events 丰富了很多。</p></blockquote><hr><h3 id="3-1-BPF-优势"><a href="#3-1-BPF-优势" class="headerlink" title="3.1 BPF 优势"></a>3.1 BPF 优势</h3><p>● Making the kernel programmable without having to cross kernel/user space boundaries</p><p>● Given the flflexibility of a programmable data path</p><p>● BPF programs can be updated without restart kernel</p><p>● BPF provides a stable API to user space</p><p>● Kernel guarantees safety, BPF programs never crash kernel </p><hr><h3 id="3-2-BPF-指令集"><a href="#3-2-BPF-指令集" class="headerlink" title="3.2 BPF 指令集"></a>3.2 BPF 指令集</h3><p>● <strong>Eleven 64 bit registers (r0~r10) with</strong> 32 bit sub registers (zero-exntend)</p><p>​    ○ r10 (ro, fp)</p><p>​    ○ r0 (ret val)</p><p>​    ○ r1 - r5 (args to helper func)</p><p>​    ○ r1 (ctx defifined by prog_type) </p><p>​    ○ r6 - r9 (callee saved regs on helper func call) </p><p>● One PC register</p><p>● 512B BPF stack space</p><p>Map one to one to HW CPU </p><p>regs, when jit enabled</p><p><strong>Limit</strong></p><p>● BPF_CALL0 ~ BPF_CALL5</p><p>● Max 4096 insts per prog</p><p>● Verififier fobids loops (kernel 5.3 will </p><p>support bounded loops)</p><p>● Max 32 tail calls</p><blockquote><p>依旧是不太了解，但只是一个概念。</p></blockquote><hr><h2 id="3-3-BPF-Help-Functions"><a href="#3-3-BPF-Help-Functions" class="headerlink" title="3.3 BPF Help Functions"></a>3.3 <strong>BPF Help Functions</strong></h2><h4 id="3-3-1-定义"><a href="#3-3-1-定义" class="headerlink" title="3.3.1 定义"></a>3.3.1 定义</h4><p>Helper functions are a concept which enables BPF programs to consult a core kernel defifined set of function calls in order to retrieve / push data from /to the kernel. Available helper functions may differ for each BPF program type.</p><blockquote><p>不同的BPF程序类型可用的helper functions 不同。</p></blockquote><h4 id="3-3-2-样例"><a href="#3-3-2-样例" class="headerlink" title="3.3.2  样例"></a>3.3.2  样例</h4><ol><li>bpf_probe_read()</li><li>bpf_ktime_get_ns()</li><li>bpf_get_current_pid_tgid()</li><li>bpf_get_current_uid_gid()</li><li>bpf_get_current_comm()</li><li>bpf_get_current_task()</li><li>bpf_log2l()</li><li>bpf_get_prandom_u32()</li><li>bpf_trace_printk()</li><li>perf_submit()</li></ol><blockquote><p>有啥用呢 具体看bcc程序。</p></blockquote><hr><h2 id="3-4-bpf-program-type"><a href="#3-4-bpf-program-type" class="headerlink" title="3.4 bpf_program_type"></a>3.4 <strong>bpf_program_type</strong></h2><p>目前我关注的是<code>BPF_PROG_TYPE_KPROBE </code></p><p><code>    BPF_PROG_TYPE_TRACEPOINT</code></p><p>其他暂且不管。</p><p><a href="https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/bpf.h#L171">https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/bpf.h#L171</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">enum bpf_prog_type &#123;</span><br><span class="line">BPF_PROG_TYPE_UNSPEC,</span><br><span class="line">BPF_PROG_TYPE_SOCKET_FILTER,</span><br><span class="line">BPF_PROG_TYPE_KPROBE,</span><br><span class="line">BPF_PROG_TYPE_SCHED_CLS,</span><br><span class="line">BPF_PROG_TYPE_SCHED_ACT,</span><br><span class="line">BPF_PROG_TYPE_TRACEPOINT,</span><br><span class="line">BPF_PROG_TYPE_XDP,</span><br><span class="line">BPF_PROG_TYPE_PERF_EVENT,</span><br><span class="line">BPF_PROG_TYPE_CGROUP_SKB,</span><br><span class="line">BPF_PROG_TYPE_CGROUP_SOCK,</span><br><span class="line">BPF_PROG_TYPE_LWT_IN,</span><br><span class="line">BPF_PROG_TYPE_LWT_OUT,</span><br><span class="line">BPF_PROG_TYPE_LWT_XMIT,</span><br><span class="line">BPF_PROG_TYPE_SOCK_OPS,</span><br><span class="line">BPF_PROG_TYPE_SK_SKB,</span><br><span class="line">BPF_PROG_TYPE_CGROUP_DEVICE,</span><br><span class="line">BPF_PROG_TYPE_SK_MSG,</span><br><span class="line">BPF_PROG_TYPE_RAW_TRACEPOINT,</span><br><span class="line">BPF_PROG_TYPE_CGROUP_SOCK_ADDR,</span><br><span class="line">BPF_PROG_TYPE_LWT_SEG6LOCAL,</span><br><span class="line">BPF_PROG_TYPE_LIRC_MODE2,</span><br><span class="line">BPF_PROG_TYPE_SK_REUSEPORT,</span><br><span class="line">BPF_PROG_TYPE_FLOW_DISSECTOR,</span><br><span class="line">BPF_PROG_TYPE_CGROUP_SYSCTL,</span><br><span class="line">BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE,</span><br><span class="line">BPF_PROG_TYPE_CGROUP_SOCKOPT,</span><br><span class="line">BPF_PROG_TYPE_TRACING,</span><br><span class="line">BPF_PROG_TYPE_STRUCT_OPS,</span><br><span class="line">BPF_PROG_TYPE_EXT,</span><br><span class="line">BPF_PROG_TYPE_LSM,</span><br><span class="line">BPF_PROG_TYPE_SK_LOOKUP,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>具体参考<a href="https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md">https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md</a></p><blockquote><p> todo:有啥用呢。具体看待会bcc程序</p></blockquote><hr><h2 id="3-5-BPF-Maps"><a href="#3-5-BPF-Maps" class="headerlink" title="3.5 BPF Maps"></a>3.5 BPF Maps</h2><p><img src="https://i.imgur.com/CJugUJE.png" alt="img"></p><blockquote><p>图片上直观的认知。BPF map 打通了内核态和用户态的数据传递。</p></blockquote><hr><h3 id="3-5-1-Maps-types"><a href="#3-5-1-Maps-types" class="headerlink" title="3.5.1 Maps types"></a>3.5.1 Maps types</h3><p>Current Generic Maps</p><p>● BPF_MAP_TYPE_HASH</p><p>● BPF_MAP_TYPE_ARRAY</p><p>● BPF_MAP_TYPE_PERCPU_HASH</p><p>● BPF_MAP_TYPE_PERCPU_ARRAY</p><p>● BPF_MAP_TYPE_LRU_HASH</p><p>● BPF_MAP_TYPE_LRU_PERCPU_HASH </p><p>● BPF_MAP_TYPE_LPM_TRIE</p><p>Current Non-Generic Maps</p><p>● BPF_MAP_TYPE_PROG_ARRAY</p><p>● BPF_MAP_TYPE_PERF_EVENT_ARRAY</p><p>● BPF_MAP_TYPE_CGROUP_ARRAY</p><p>● BPF_MAP_TYPE_STACK_TRACE</p><p>● BPF_MAP_TYPE_ARRAY_OF_MAPS</p><p>● BPF_MAP_TYPE_HASH_OF_MAPS </p><p>对底层key/value进行封装。</p><blockquote><p>目前我只关注前两个 BPF_MAP_TYPE_HASH  BPF_MAP_TYPE_ARRAY</p><p>有啥用、如何用，具体看bcc程序。</p></blockquote><hr><h3 id="3-5-2-BPF-MAP"><a href="#3-5-2-BPF-MAP" class="headerlink" title="3.5.2 BPF MAP"></a>3.5.2 BPF MAP</h3><p>● Kernel header</p><p>bpf/bpf_helpers.h</p><p>● User-space header</p><p>tools/lib/bpf/bpf.h</p><p>The differences</p><p>● in user-space use the fd to access the map, rather than using the pointer to the map directly.</p><p>● Bpf_map_get_next_key can only be used in user-space</p><blockquote><p>用户态用文件描述fd访问map,内核态直接用指针访问map.</p><p>Bpf_map_get_next_key  只能在用户态使用</p></blockquote><hr><h3 id="3-5-3-Loader"><a href="#3-5-3-Loader" class="headerlink" title="3.5.3 Loader"></a>3.5.3 Loader</h3><p>● bcc/bpftrace</p><p>● perf</p><p>● iproute2 (ip tc)</p><p>● ebpf_exporter</p><p>● cilium</p><blockquote><p> BPF需要加载到内核。上面是一些可用的loader。</p></blockquote><hr><p>接下来。我希望用 bcc 代码把上面提到的几个点都串起来。</p><ul><li>Helper Functions</li><li>maps</li><li>bpf_program_type</li></ul><h2 id="4-BCC"><a href="#4-BCC" class="headerlink" title="4.BCC"></a>4.BCC</h2><h3 id="4-1-安装-bcc-环境"><a href="#4-1-安装-bcc-环境" class="headerlink" title="4.1 安装 bcc 环境"></a>4.1 安装 bcc 环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ubuntu18.04</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get -y install bison build-essential cmake flex git libedit-dev libllvm6.0 llvm-6.0-dev libclang-6.0-dev python zlib1g-dev libelf-dev libfl-dev</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/iovisor/bcc.git</span><br><span class="line">mkdir bcc/build; <span class="built_in">cd</span> bcc/build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line">cmake -DPYTHON_CMD=python3 .. <span class="comment"># build python3 binding</span></span><br><span class="line"><span class="built_in">pushd</span> src/python/</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line"><span class="built_in">popd</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="4-2-tools-vfsstat-py"><a href="#4-2-tools-vfsstat-py" class="headerlink" title="4.2 tools/vfsstat.py"></a>4.2 tools/vfsstat.py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">bpf_text = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">#include &lt;uapi/linux/ptrace.h&gt;</span></span><br><span class="line"><span class="string">enum stat_types &#123;</span></span><br><span class="line"><span class="string">    S_READ = 1,</span></span><br><span class="line"><span class="string">    S_WRITE,</span></span><br><span class="line"><span class="string">    S_FSYNC,</span></span><br><span class="line"><span class="string">    S_OPEN,</span></span><br><span class="line"><span class="string">    S_CREATE,</span></span><br><span class="line"><span class="string">    S_MAXSTAT</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">BPF_ARRAY(stats, u64, S_MAXSTAT);</span></span><br><span class="line"><span class="string">static void stats_increment(int key) &#123;</span></span><br><span class="line"><span class="string">    u64 *leaf = stats.lookup(&amp;key);</span></span><br><span class="line"><span class="string">    if (leaf) (*leaf)++;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">bpf_text_kprobe = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">void do_read(struct pt_regs *ctx) &#123; stats_increment(S_READ); &#125;</span></span><br><span class="line"><span class="string">void do_write(struct pt_regs *ctx) &#123; stats_increment(S_WRITE); &#125;</span></span><br><span class="line"><span class="string">void do_fsync(struct pt_regs *ctx) &#123; stats_increment(S_FSYNC); &#125;</span></span><br><span class="line"><span class="string">void do_open(struct pt_regs *ctx) &#123; stats_increment(S_OPEN); &#125;</span></span><br><span class="line"><span class="string">void do_create(struct pt_regs *ctx) &#123; stats_increment(S_CREATE); &#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">bpf_text_kfunc = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">KFUNC_PROBE(vfs_read, int unused)   &#123; stats_increment(S_READ); return 0; &#125;</span></span><br><span class="line"><span class="string">KFUNC_PROBE(vfs_write, int unused)  &#123; stats_increment(S_WRITE); return 0; &#125;</span></span><br><span class="line"><span class="string">KFUNC_PROBE(vfs_fsync, int unused)  &#123; stats_increment(S_FSYNC); return 0; &#125;</span></span><br><span class="line"><span class="string">KFUNC_PROBE(vfs_open, int unused)   &#123; stats_increment(S_OPEN); return 0; &#125;</span></span><br><span class="line"><span class="string">KFUNC_PROBE(vfs_create, int unused) &#123; stats_increment(S_CREATE); return 0; &#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">is_support_kfunc = BPF.support_kfunc()</span><br><span class="line"><span class="comment">#is_support_kfunc = False #BPF.support_kfunc()</span></span><br><span class="line"><span class="keyword">if</span> is_support_kfunc:</span><br><span class="line">    bpf_text += bpf_text_kfunc</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    bpf_text += bpf_text_kprobe</span><br><span class="line"></span><br><span class="line">b = BPF(text=bpf_text)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> is_support_kfunc:</span><br><span class="line">    b.attach_kprobe(event=<span class="string">&quot;vfs_read&quot;</span>,   fn_name=<span class="string">&quot;do_read&quot;</span>)</span><br><span class="line">    b.attach_kprobe(event=<span class="string">&quot;vfs_write&quot;</span>,  fn_name=<span class="string">&quot;do_write&quot;</span>)</span><br><span class="line">    b.attach_kprobe(event=<span class="string">&quot;vfs_fsync&quot;</span>,  fn_name=<span class="string">&quot;do_fsync&quot;</span>)</span><br><span class="line">    b.attach_kprobe(event=<span class="string">&quot;vfs_open&quot;</span>,   fn_name=<span class="string">&quot;do_open&quot;</span>)</span><br><span class="line">    b.attach_kprobe(event=<span class="string">&quot;vfs_create&quot;</span>, fn_name=<span class="string">&quot;do_create&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># stat column labels and indexes</span></span><br><span class="line">stat_types = &#123;</span><br><span class="line">    <span class="string">&quot;READ&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;WRITE&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&quot;FSYNC&quot;</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">&quot;OPEN&quot;</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="string">&quot;CREATE&quot;</span>: <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># header</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%-8s  &quot;</span> % <span class="string">&quot;TIME&quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> stype <span class="keyword">in</span> stat_types.keys():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; %8s&quot;</span> % (stype + <span class="string">&quot;/s&quot;</span>), end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    idx = stat_types[stype]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> count &gt; <span class="number">0</span>:</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; count:</span><br><span class="line">            exit()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sleep(interval)</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        exit()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%-8s: &quot;</span> % strftime(<span class="string">&quot;%H:%M:%S&quot;</span>), end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="comment"># print each statistic as a column</span></span><br><span class="line">    <span class="keyword">for</span> stype <span class="keyword">in</span> stat_types.keys():</span><br><span class="line">        idx = stat_types[stype]</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            val = b[<span class="string">&quot;stats&quot;</span>][c_int(idx)].value / interval</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot; %8d&quot;</span> % val, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot; %8d&quot;</span> % <span class="number">0</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    b[<span class="string">&quot;stats&quot;</span>].clear()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><blockquote><p> 最重要的代码解读 明天写</p></blockquote><h3 id="4-3-tools-biosnoop-py"><a href="#4-3-tools-biosnoop-py" class="headerlink" title="4.3 tools/biosnoop.py"></a>4.3 tools/biosnoop.py</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;uapi/linux/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/blkdev.h&gt;</span></span></span><br><span class="line"><span class="comment">// for saving the timestamp and __data_len of each request</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">start_req_t</span> &#123;</span></span><br><span class="line">    u64 ts;</span><br><span class="line">    u64 data_len;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">val_t</span> &#123;</span></span><br><span class="line">    u64 ts;</span><br><span class="line">    u32 pid;</span><br><span class="line">    <span class="keyword">char</span> name[TASK_COMM_LEN];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data_t</span> &#123;</span></span><br><span class="line">    u32 pid;</span><br><span class="line">    u64 rwflag;</span><br><span class="line">    u64 delta;</span><br><span class="line">    u64 qdelta;</span><br><span class="line">    u64 sector;</span><br><span class="line">    u64 len;</span><br><span class="line">    u64 ts;</span><br><span class="line">    <span class="keyword">char</span> disk_name[DISK_NAME_LEN];</span><br><span class="line">    <span class="keyword">char</span> name[TASK_COMM_LEN];</span><br><span class="line">&#125;;</span><br><span class="line">BPF_HASH(start, struct request *, struct <span class="keyword">start_req_t</span>);</span><br><span class="line">BPF_HASH(infobyreq, struct request *, struct <span class="keyword">val_t</span>);</span><br><span class="line">BPF_PERF_OUTPUT(events);</span><br><span class="line"><span class="comment">// cache PID and comm by-req</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trace_pid_start</span><span class="params">(struct pt_regs *ctx, struct request *req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">val_t</span> <span class="title">val</span> =</span> &#123;&#125;;</span><br><span class="line">    u64 ts;</span><br><span class="line">    <span class="keyword">if</span> (bpf_get_current_comm(&amp;val.name, <span class="keyword">sizeof</span>(val.name)) == <span class="number">0</span>) &#123;</span><br><span class="line">        val.pid = bpf_get_current_pid_tgid() &gt;&gt; <span class="number">32</span>;</span><br><span class="line">        <span class="keyword">if</span> (##QUEUE##) &#123;</span><br><span class="line">            val.ts = bpf_ktime_get_ns();</span><br><span class="line">        &#125;</span><br><span class="line">        infobyreq.update(&amp;req, &amp;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// time block I/O</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trace_req_start</span><span class="params">(struct pt_regs *ctx, struct request *req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">start_req_t</span> <span class="title">start_req</span> =</span> &#123;</span><br><span class="line">        .ts = bpf_ktime_get_ns(),</span><br><span class="line">        .data_len = req-&gt;__data_len</span><br><span class="line">    &#125;;</span><br><span class="line">    start.update(&amp;req, &amp;start_req);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trace_req_completion</span><span class="params">(struct pt_regs *ctx, struct request *req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">start_req_t</span> *<span class="title">startp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">val_t</span> *<span class="title">valp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">data_t</span> <span class="title">data</span> =</span> &#123;&#125;;</span><br><span class="line">    u64 ts;</span><br><span class="line">    <span class="comment">// fetch timestamp and calculate delta</span></span><br><span class="line">    startp = start.lookup(&amp;req);</span><br><span class="line">    <span class="keyword">if</span> (startp == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// missed tracing issue</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ts = bpf_ktime_get_ns();</span><br><span class="line">    data.delta = ts - startp-&gt;ts;</span><br><span class="line">    data.ts = ts / <span class="number">1000</span>;</span><br><span class="line">    data.qdelta = <span class="number">0</span>;</span><br><span class="line">    valp = infobyreq.lookup(&amp;req);</span><br><span class="line">    data.len = startp-&gt;data_len;</span><br><span class="line">    <span class="keyword">if</span> (valp == <span class="number">0</span>) &#123;</span><br><span class="line">        data.name[<span class="number">0</span>] = <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">        data.name[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (##QUEUE##) &#123;</span><br><span class="line">            data.qdelta = startp-&gt;ts - valp-&gt;ts;</span><br><span class="line">        &#125;</span><br><span class="line">        data.pid = valp-&gt;pid;</span><br><span class="line">        data.sector = req-&gt;__sector;</span><br><span class="line">        bpf_probe_read_kernel(&amp;data.name, <span class="keyword">sizeof</span>(data.name), valp-&gt;name);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">gendisk</span> *<span class="title">rq_disk</span> =</span> req-&gt;rq_disk;</span><br><span class="line">        bpf_probe_read_kernel(&amp;data.disk_name, <span class="keyword">sizeof</span>(data.disk_name),</span><br><span class="line">                       rq_disk-&gt;disk_name);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The following deals with a kernel version change (in mainline 4.7, although</span></span><br><span class="line"><span class="comment"> * it may be backported to earlier kernels) with how block request write flags</span></span><br><span class="line"><span class="comment"> * are tested. We handle both pre- and post-change versions here. Please avoid</span></span><br><span class="line"><span class="comment"> * kernel version tests like this as much as possible: they inflate the code,</span></span><br><span class="line"><span class="comment"> * test, and maintenance burden.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> REQ_WRITE</span></span><br><span class="line">    data.rwflag = !!(req-&gt;cmd_flags &amp; REQ_WRITE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(REQ_OP_SHIFT)</span></span><br><span class="line">    data.rwflag = !!((req-&gt;cmd_flags &gt;&gt; REQ_OP_SHIFT) == REQ_OP_WRITE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    data.rwflag = !!((req-&gt;cmd_flags &amp; REQ_OP_MASK) == REQ_OP_WRITE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    events.perf_submit(ctx, &amp;data, <span class="keyword">sizeof</span>(data));</span><br><span class="line">    start.<span class="keyword">delete</span>(&amp;req);</span><br><span class="line">    infobyreq.<span class="keyword">delete</span>(&amp;req);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>最重要的代码解读明天写</p></blockquote><hr><h3 id="4-4-如果没有bcc呢"><a href="#4-4-如果没有bcc呢" class="headerlink" title="4.4 如果没有bcc呢?"></a>4.4 如果没有bcc呢?</h3><p>参考一位师兄的博客。</p><p><a href="https://blog.csdn.net/qq_34258344/article/details/108932912">Ubuntu下bpf纯c程序的编写与运行</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文基本上是对 PingCAP wenbo zhang  &lt;a href=&quot;https://www.bilibili.com/video/BV1B4411S7PP&quot;&gt;Infra Meetup  No.111&lt;/a&gt; 的笔记，还有对&lt;code&gt;bcc&lt;/code&gt;的一些学习整理。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>bcc/MySQL相关踩坑过程</title>
    <link href="http://example.com/2021/04/08/bcc-mysql%E7%9B%B8%E5%85%B3%E8%B8%A9%E5%9D%91%E8%BF%87%E7%A8%8B/"/>
    <id>http://example.com/2021/04/08/bcc-mysql%E7%9B%B8%E5%85%B3%E8%B8%A9%E5%9D%91%E8%BF%87%E7%A8%8B/</id>
    <published>2021-04-08T14:54:17.000Z</published>
    <updated>2023-05-14T13:50:41.560Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>毕设做的是用 ebpf 对 MySQL tracing/monitor 的一个项目。本着站在巨人的肩膀上前行的想法，先看看bcc 中MySQL相关的工具。如果能在bcc工具基础上修改，那就再好不过了。</p><a id="more"></a> <h3 id="1-bcc"><a href="#1-bcc" class="headerlink" title="1. bcc"></a>1. bcc</h3><p>对 bcc 项目进行全局搜索。</p><p>bcc/tools 目录下相关于MySQL 的工具有 <code>dbstat.py</code> <code>dbslower.py</code></p><p>代码看着都还挺像回事的。</p><p> <code>Copyright 2017, Sasha Goldshtein</code> </p><p>都是这位大佬<code>Sasha Goldshtein</code> 在17年完成的。</p><p>直接开搞。RUN IT!</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python3 dbstat.py mysql </span><br></pre></td></tr></table></figure><p>出现了报错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">raise</span> USDTException(<span class="string">&quot;USDT failed to instrument PID %d&quot;</span> % pid)</span><br><span class="line">  bcc.usdt.USDTException: USDT failed to instrument PID <span class="number">4803</span></span><br></pre></td></tr></table></figure><p>google it!</p><p>在bcc的issue中提到了这个报错。</p><p><a href="https://github.com/iovisor/bcc/issues/2330">https://github.com/iovisor/bcc/issues/2330</a></p><p>yonghong-song 提到</p><blockquote><p> You need to recompile <code>mysqld</code> with usdt support. See</p><p><a href="https://github.com/iovisor/bcc/blob/master/man/man8/mysqld_qslower.8#L17-L18">https://github.com/iovisor/bcc/blob/master/man/man8/mysqld_qslower.8#L17-L18</a></p></blockquote><p>顺藤摸瓜。</p><p>发现默认的 MySQL 并没有开启 dtrace。</p><p>需要在编译 MySQL 的时候带上参数<code>-DENABLE_DTRACE=1</code>。</p><p>同时也发现在<code>dbstat.py</code> <code>dbslower.py</code>的注释中都有提到这一点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dbstat.py</span><br><span class="line"># This tool uses USDT probes, which means it needs MySQL and PostgreSQL built</span><br><span class="line"># with USDT (DTrace) support.</span><br><span class="line"></span><br><span class="line">dbslower.py</span><br><span class="line"># Script works in two different modes:</span><br><span class="line"># 1) USDT probes, which means it needs MySQL and PostgreSQL built with USDT (DTrace) support.</span><br></pre></td></tr></table></figure><p><strong>现在问题就转化为编译安装MySQL并在编译时带上参数。事情在现在看来都是可解决的。</strong></p><h3 id="2-compile-MySQL"><a href="#2-compile-MySQL" class="headerlink" title="2 .compile MySQL"></a>2 .compile MySQL</h3><p>步骤看着挺简单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone --depth&#x3D;1 https:&#x2F;&#x2F;github.com&#x2F;MariaDB&#x2F;server mariadb</span><br><span class="line">cmake . -DENABLE_DTRACE&#x3D;1</span><br><span class="line">make -j $NUMPROCS</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>当<code>make</code> 的时候遇到报错</p><p>类似<a href="https://github.com/iovisor/bcc/issues/2233">https://github.com/iovisor/bcc/issues/2233</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make[2]: DTRACE-NOTFOUND: Command not found</span><br></pre></td></tr></table></figure><p>貌似是缺失dtrace . 需要确认一下。</p><p><code>issue2233</code> 里面提到了一个重要文档。<br><a href="https://dev.mysql.com/doc/refman/5.7/en/dba-dtrace-server.html">https://dev.mysql.com/doc/refman/5.7/en/dba-dtrace-server.html</a></p><p>问题又转化成安装 dtrace.</p><h3 id="三-dtrace"><a href="#三-dtrace" class="headerlink" title="三: dtrace"></a>三: dtrace</h3><h4 id="3-1dtrace-是什么？"><a href="#3-1dtrace-是什么？" class="headerlink" title="3.1dtrace 是什么？"></a>3.1dtrace 是什么？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DTrace 是动态追踪技术的鼻祖，它于 21 世纪初诞生于 Solaris 操作系统，</span><br><span class="line">是由原来的 Sun Microsystems 公司的工程师编写的，</span><br><span class="line">先后被移植到 Linux、FreeBSD、NetBSD 及 Mac OS X 等操作系统上。</span><br><span class="line">iOS 系统也有，大名鼎鼎的 Instrument 工具就是基于 DTrace 实现的，</span><br><span class="line">而且更多的功能还在随着 iOS 系统进行版本迭代。</span><br></pre></td></tr></table></figure><h4 id="3-2-dtrace-with-MySQL"><a href="#3-2-dtrace-with-MySQL" class="headerlink" title="3.2 dtrace with MySQL"></a>3.2 dtrace with MySQL</h4><p>处理刚才提到的 MySQL 官方文档。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MySQL includes support for DTrace probes on these platforms:</span><br><span class="line"></span><br><span class="line">Solaris 10 Update 5 (Solaris 5&#x2F;08) on SPARC, x86 and x86_64 platforms</span><br><span class="line"></span><br><span class="line">OS X 10.4 and higher</span><br><span class="line"></span><br><span class="line">Oracle Linux 6 and higher with UEK kernel (as of MySQL 5.7.5)</span><br><span class="line"></span><br><span class="line">Enabling the probes should be automatic on these platforms. To explicitly enable or disable the probes during building, use the -DENABLE_DTRACE&#x3D;1 or -DENABLE_DTRACE&#x3D;0 option to CMake.</span><br><span class="line"></span><br><span class="line">If a non-Solaris platform includes DTrace support, building mysqld on that platform includes DTrace support.</span><br></pre></td></tr></table></figure><p>翻译如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MySQL在这些平台上支持DTrace探针：</span><br><span class="line"></span><br><span class="line">Solaris 10 Update 5 (Solaris 5&#x2F;08) on SPARC, x86 and x86_64 platforms</span><br><span class="line">OS X 10.4 and higher</span><br><span class="line">Oracle Linux 6 and higher with UEK kernel (as of MySQL 5.7.5)</span><br><span class="line"></span><br><span class="line">在这些平台上应该是自动的 启用探针。 要在构建过程中明确启用或禁用探针，请使用CMake的-DENABLE_DTRACE &#x3D; 1或-DENABLE_DTRACE &#x3D; 0选项。</span><br><span class="line"></span><br><span class="line">如果非Solaris平台包含DTrace支持，则在该平台上构建mysqld将包含DTrace支持。</span><br></pre></td></tr></table></figure><p>得到了关键信息。在ubuntu 或 Linux 下使用 dtrace 需要编译。</p><p>只是更明确了一下。</p><p><strong>问题现在聚焦于解决编译 MySQL 时的报错。</strong></p><h4 id="3-3-dtrace4linux"><a href="#3-3-dtrace4linux" class="headerlink" title="3.3 dtrace4linux"></a>3.3 dtrace4linux</h4><p>google  如何在linux 平台上安装dtrace 指向了这么一个仓库。</p><p><a href="https://github.com/dtrace4linux/linux">https://github.com/dtrace4linux/linux</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This is a port of the Sun DTrace user and kernel code to Linux. No linux kernel code is touched in this build, but what is produced is a dynamically loadable kernel module. This avoids licensing issues and allows people to load and update dtrace as they desire.</span><br><span class="line"></span><br><span class="line">The goal of this project is to make available DTrace for the Linux platforms. By making it available for everyone, they can use it to optimise their systems and tools, and in return, I get to benefit from their work.</span><br></pre></td></tr></table></figure><p>问题好像变得只需要需要dtrace4linux就行了。</p><p>ubuntu/fedora 上就能有 dtrace.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ tools&#x2F;get-deps-arch.sh# if using ArchLinux</span><br><span class="line">$ tools&#x2F;get-deps.pl # if using Ubuntu</span><br><span class="line">$ tools&#x2F;get-deps-fedora.sh# RedHat&#x2F;Fedora</span><br><span class="line"></span><br><span class="line">$ make all</span><br><span class="line">$ make install</span><br><span class="line">$ make load           (need to be root or have sudo access)</span><br></pre></td></tr></table></figure><p>执行上面的命令。在<code>make all</code>遇到报错。 </p><p>ubuntu下遇到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fatal error: &#x2F;usr&#x2F;include&#x2F;sys&#x2F;types.h: No such file or directory</span><br><span class="line">  142 |  # include &quot;&#x2F;usr&#x2F;include&#x2F;sys&#x2F;types.h&quot;</span><br><span class="line">      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~</span><br></pre></td></tr></table></figure><p>切到 fedora 该问题解决。但是又碰到新问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Make all error - FATAL ERROR: cannot find old_rsp FATAL ERROR: build.pl aborting</span><br></pre></td></tr></table></figure><p>google it.</p><p>发现issue <a href="https://github.com/dtrace4linux/linux/issues/113">https://github.com/dtrace4linux/linux/issues/113</a></p><blockquote><p>大家都遇到了同样的问题，且没有解决方案。</p></blockquote><p>再看了看 dtrace4linux 应该是不再维护了。</p><p>至此这条路是走不通了。</p><p>way 2: <code>Solaris 10</code> 直接自带。但不是 linux 系统, make no sense.</p><p>way 3: <a href="https://blogs.oracle.com/linux/dtrace-on-fedora">https://blogs.oracle.com/linux/dtrace-on-fedora</a></p><p>直接编译dtrace内核模块 编译fedora. </p><p>耗时几个小时，    </p><p>测试在拉fedora 源码这一步就因为网络不稳定进行不下去了。</p><p>而且这种方式看起来过于暴力了。</p><hr><h3 id="4-Last"><a href="#4-Last" class="headerlink" title="4.Last"></a>4.Last</h3><p>另一个方向: use uprobe</p><p>关键的一条信息:</p><p><a href="http://minervadb.com/wp-content/uploads/2020/12/Dynamic-Tracing-for-Finding-and-Solving-MySQL-Performance-Problems-on-Linux-MinervaDB-Database-Platforms-Virtual-Conference-2020.pdf">http://minervadb.com/wp-content/uploads/2020/12/Dynamic-Tracing-for-Finding-and-Solving-MySQL-Performance-Problems-on-Linux-MinervaDB-Database-Platforms-Virtual-Conference-2020.pdf</a></p><p>page 14</p><blockquote><p> hard way to go…</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;毕设做的是用 ebpf 对 MySQL tracing/monitor 的一个项目。本着站在巨人的肩膀上前行的想法，先看看bcc 中MySQL相关的工具。如果能在bcc工具基础上修改，那就再好不过了。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>2020年终总结</title>
    <link href="http://example.com/2020/12/31/2020%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2020/12/31/2020%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</id>
    <published>2020-12-31T09:05:18.000Z</published>
    <updated>2023-05-14T13:50:41.557Z</updated>
    
    <content type="html"><![CDATA[<p>In short.</p><a id="more"></a> <hr><p>1月 在家打云顶之弈和玩剧本杀</p><p>2月 在家打云顶之弈和玩剧本杀 值得一提的是在大年初一和云正式分手了</p><p>3月 开学了,远程上课 开始慌了开始找实习,海投简历</p><p>4月 前半个月面试 后半个月在下厨房实习</p><p>5月 在下厨房实习</p><p>6月 前半个月还在下厨房 6月下半月来到深圳，休息了一周，又考试了一周</p><p>7 月 8 月 在腾讯实习 7月应该是又是发生我最痛苦的病 直接导致我过年都不想回家了 开始喜欢上了一个女孩，尽管景象已经差不多是我自己幻想出来的,代表着我心中的美好吧..(然后现在感觉有点幻灭了，想象力不够了</p><p>9 月 10月 心态爆炸的两个月 在打云顶之弈、看小说、看电视剧、痛苦地混日子 失去梦想 被没钱和闲鱼折磨</p><p>11月前半个月 在整talent-plan 和整ebpf</p><p>11月后半个月 开始为了面试刷题</p><p>12月 前半个月为了面试刷题 后半个月开始背单词 跑步当然主要时间还是在刷题</p><hr><p>这么以第三人称的描述自己，突然感觉没啥好聊的。</p><p>想一想好像今年就是这么过去了。有意思的很，四个地图。北京、西安、深圳、家 大学四年没这么丰富。</p><p>今年也算圆满结束吧。</p><p>终于和浪哥提了实习生流程的事情，并没有想象中的那么麻烦。结束了最后的念想。无数次刷新腾讯招聘官网的状态。想要状态变转正。尽管那个时候立下誓言，死也不找这么累的工作，结果现在被找不到工作的恐惧打败…</p><p>结束了今年唯一一次秋招面试。虽然留有遗憾、最后一面的发挥并不是很好。心里还不甘心，这一个半月都在为这个目标而努力。</p><p>今天在pythonhunter的telegram群里聊天又意外有一个thoughtworks机会。于是乎趁热打铁又把铃盛投了。想清楚了，大不了把它当作一个白天工作来做(参考黑客与画家)，不想再陷入全是焦虑的日子了。</p><p>怎么来评价一下今年呢。</p><p>还行吧，挺丰富的啦。有快乐也有痛苦的瞬间。</p><p>说说展望吧。</p><hr><p>1.找到一份好工作呗~最好是infra pingcap 其次就是外企 最后就是去拼命呗，糟蹋自己的身体啊。当然人的适应能力是极强的，我说不定也会适应…挺有意思的，选择一份不同的工作，可能走向的人生会完全不同。</p><p>2.好好地把这个毕业设计做完。</p><p>3.就是不那么焦虑。整个人能松下来，一直这么紧着很累。</p><p>4.就是希望自己技术有长进，操作系统的知识能补一补。最后呢对开源项目贡献一些代码。</p><p>明年会更好的吧~</p><p>That’s all.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;In short.&lt;/p&gt;</summary>
    
    
    
    <category term="生活" scheme="http://example.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode-DP 问题</title>
    <link href="http://example.com/2020/12/30/LeetCode-DP%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2020/12/30/LeetCode-DP%E9%97%AE%E9%A2%98/</id>
    <published>2020-12-30T06:55:28.000Z</published>
    <updated>2023-05-14T13:50:41.559Z</updated>
    
    <content type="html"><![CDATA[<p>dp问题~</p><a id="more"></a><p>1.编辑距离问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span>(<span class="params">self, word1, word2</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type word1: str</span></span><br><span class="line"><span class="string">        :type word2: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(word1)</span><br><span class="line">        m = <span class="built_in">len</span>(word2)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 有一个字符串为空串</span></span><br><span class="line">        <span class="keyword">if</span> n * m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> n + m</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># DP 数组</span></span><br><span class="line">        D = [ [<span class="number">0</span>] * (m + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 边界状态初始化</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>):</span><br><span class="line">            D[i][<span class="number">0</span>] = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>):</span><br><span class="line">            D[<span class="number">0</span>][j] = j</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算所有 DP 值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">                left = D[i - <span class="number">1</span>][j] + <span class="number">1</span></span><br><span class="line">                down = D[i][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                left_down = D[i - <span class="number">1</span>][j - <span class="number">1</span>] </span><br><span class="line">                <span class="keyword">if</span> word1[i - <span class="number">1</span>] != word2[j - <span class="number">1</span>]:</span><br><span class="line">                    left_down += <span class="number">1</span></span><br><span class="line">                D[i][j] = <span class="built_in">min</span>(left, down, left_down)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> D[n][m]</span><br></pre></td></tr></table></figure><hr><p>2.最长公共子序列</p><p>这是两个序列 (反而跟编辑距离类似)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span>(<span class="params">self,str1, str2</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(str1), <span class="built_in">len</span>(str2)</span><br><span class="line">        <span class="comment"># 构建 DP table 和 base case</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># 进行状态转移</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> str1[i - <span class="number">1</span>] == str2[j - <span class="number">1</span>]:</span><br><span class="line">                    <span class="comment"># 找到一个 lcs 中的字符</span></span><br><span class="line">                    dp[i][j] = <span class="number">1</span> + dp[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                  <span class="comment"># 最大的</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>3.最长上升子序列</p><p>名字听着差不多 其实差好多。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                <span class="keyword">if</span> nums[j]&lt;nums[i]:</span><br><span class="line">                    dp[i]=<span class="built_in">max</span>(dp[i],dp[j]+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure><p>4.零钱兑换一</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;dp问题~&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>LeetCode-K 个问题</title>
    <link href="http://example.com/2020/12/29/LeetCode-k%E4%B8%AA%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2020/12/29/LeetCode-k%E4%B8%AA%E9%97%AE%E9%A2%98/</id>
    <published>2020-12-29T07:51:13.000Z</published>
    <updated>2023-05-14T13:50:41.559Z</updated>
    
    <content type="html"><![CDATA[<p>这是个不能称作问题集合的问题集合</p><a id="more"></a><hr><h5 id="LEETCODE25-K个一组反转链表"><a href="#LEETCODE25-K个一组反转链表" class="headerlink" title="LEETCODE25: K个一组反转链表"></a>LEETCODE25: K个一组反转链表</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="comment"># 先写一写思路吧 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">self,head,tail</span>):</span></span><br><span class="line">        prev=tail.<span class="built_in">next</span></span><br><span class="line">        cur =head</span><br><span class="line">        <span class="comment"># 反转这边就写的有问题</span></span><br><span class="line">        <span class="comment"># 应该是prev!=tail</span></span><br><span class="line">        <span class="keyword">while</span> cur!=prev.<span class="built_in">next</span>:</span><br><span class="line">        next_p=cur.<span class="built_in">next</span></span><br><span class="line">          cur.<span class="built_in">next</span>=prev</span><br><span class="line">          prev=cur</span><br><span class="line">          cur=next_p</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> tail,head</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span>(<span class="params">self, head: ListNode, k: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># 写了两三遍了 希望这次能bug free</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line">        </span><br><span class="line">        prev=dummy</span><br><span class="line">        cur=head</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">          </span><br><span class="line">          tail=prev <span class="comment"># 保留prev</span></span><br><span class="line">          <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            tail=tail.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> tail:</span><br><span class="line">              <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">          next_p =tail.<span class="built_in">next</span><span class="comment"># 保留next</span></span><br><span class="line">          cur,tail =self.reverse(cur,tail)</span><br><span class="line">          </span><br><span class="line">          prev.<span class="built_in">next</span>=cur</span><br><span class="line">          tail.<span class="built_in">next</span>=next_p</span><br><span class="line">          </span><br><span class="line">          prev=tail</span><br><span class="line">          cur=next_p</span><br><span class="line">          </span><br><span class="line">        <span class="comment"># 先只管写吧</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">#记是记不住的只能靠自己写</span></span><br><span class="line">        <span class="comment"># k=2</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure><p>这次写的倒是还行 。就是反转这边出了一点问题。肌肉记忆了都快</p><hr><h5 id="LEETCODE23-合并K个升序链表"><a href="#LEETCODE23-合并K个升序链表" class="headerlink" title="LEETCODE23.合并K个升序链表"></a>LEETCODE23.合并K个升序链表</h5><blockquote><p>不会写</p></blockquote><p>这个归并妙啊 三目表达式用的好。这边为什么要那啥呢</p><p>归并还是很漂亮的~</p><p>思路还是清晰的~</p><p>okok股票完就下班</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//剩下的就是mergeTwoList</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoList</span><span class="params">(ListNode *l1,ListNode* l2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">nullptr</span>)<span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="literal">nullptr</span>)<span class="keyword">return</span> l1;</span><br><span class="line">        ListNode *cur = <span class="keyword">new</span> ListNode;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode;</span><br><span class="line">        cur =dummy;</span><br><span class="line">        <span class="keyword">while</span> (l1 &amp;&amp; l2)&#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val&lt;l2-&gt;val)&#123;</span><br><span class="line">                dummy-&gt;next=l1;</span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dummy-&gt;next=l2;</span><br><span class="line">                l2=l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            dummy=dummy-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l1 != <span class="literal">nullptr</span>)dummy-&gt;next=l1;</span><br><span class="line">        <span class="keyword">if</span> (l2 != <span class="literal">nullptr</span>)dummy-&gt;next=l2;</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==right)&#123;</span><br><span class="line">            <span class="keyword">return</span> lists[left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">int</span> mid = (left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//这边还是容易忘</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergeTwoList</span>(<span class="built_in">merge</span>(lists,left,mid),<span class="built_in">merge</span>(lists,mid+<span class="number">1</span>,right));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(lists,<span class="number">0</span>,lists.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是个不能称作问题集合的问题集合&lt;/p&gt;</summary>
    
    
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>SQL 题整理</title>
    <link href="http://example.com/2020/12/29/sql%E9%A2%98%E6%94%B6%E5%BD%95/"/>
    <id>http://example.com/2020/12/29/sql%E9%A2%98%E6%94%B6%E5%BD%95/</id>
    <published>2020-12-28T23:52:22.000Z</published>
    <updated>2023-05-14T13:50:41.562Z</updated>
    
    <content type="html"><![CDATA[<p>收录一些比较有意思的sql题，纯粹图一乐</p><a id="more"></a> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Employee 表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。</span><br><span class="line"></span><br><span class="line">+----+-------+--------+-----------+</span><br><span class="line">| Id | Name  | Salary | ManagerId |</span><br><span class="line">+----+-------+--------+-----------+</span><br><span class="line">| 1  | Joe   | 70000  | 3         |</span><br><span class="line">| 2  | Henry | 80000  | 4         |</span><br><span class="line">| 3  | Sam   | 60000  | NULL      |</span><br><span class="line">| 4  | Max   | 90000  | NULL      |</span><br><span class="line">+----+-------+--------+-----------+</span><br><span class="line">给定 Employee 表，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名。在上面的表格中，Joe 是唯一一个收入超过他的经理的员工。</span><br><span class="line"></span><br><span class="line">+----------+</span><br><span class="line">| Employee |</span><br><span class="line">+----------+</span><br><span class="line">| Joe      |</span><br><span class="line">+----------+</span><br></pre></td></tr></table></figure><blockquote><p>倒挂 。收集倒挂的同学 哈哈 代码太优美了~</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.Name Employee</span><br><span class="line">    <span class="keyword">from</span> Employee a</span><br><span class="line">    <span class="keyword">join</span> Employee b</span><br><span class="line">    <span class="keyword">on</span> a.ManagerId <span class="operator">=</span> b.Id <span class="keyword">and</span> a.Salary<span class="operator">&gt;</span>b.Salary</span><br></pre></td></tr></table></figure><hr><p>182.查找重复的电子邮箱</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">编写一个 SQL 查询，查找 Person 表中所有重复的电子邮箱。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">+----+---------+</span><br><span class="line">| Id | Email   |</span><br><span class="line">+----+---------+</span><br><span class="line">| 1  | a@b.com |</span><br><span class="line">| 2  | c@d.com |</span><br><span class="line">| 3  | a@b.com |</span><br><span class="line">+----+---------+</span><br><span class="line">根据以上输入，你的查询应返回以下结果：</span><br><span class="line"></span><br><span class="line">+---------+</span><br><span class="line">| Email   |</span><br><span class="line">+---------+</span><br><span class="line">| a@b.com |</span><br><span class="line">+---------+</span><br></pre></td></tr></table></figure><p>就是group by的简单应用 记住having</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Email</span><br><span class="line"><span class="keyword">from</span> Person</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> Email</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(Email)<span class="operator">&gt;=</span><span class="number">2</span></span><br></pre></td></tr></table></figure><hr><p>183.从不订购的客户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">某网站包含两个表，Customers 表和 Orders 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。</span><br><span class="line"></span><br><span class="line">Customers 表：</span><br><span class="line"></span><br><span class="line">+----+-------+</span><br><span class="line">| Id | Name  |</span><br><span class="line">+----+-------+</span><br><span class="line">| 1  | Joe   |</span><br><span class="line">| 2  | Henry |</span><br><span class="line">| 3  | Sam   |</span><br><span class="line">| 4  | Max   |</span><br><span class="line">+----+-------+</span><br><span class="line">Orders 表：</span><br><span class="line"></span><br><span class="line">+----+------------+</span><br><span class="line">| Id | CustomerId |</span><br><span class="line">+----+------------+</span><br><span class="line">| 1  | 3          |</span><br><span class="line">| 2  | 1          |</span><br><span class="line">+----+------------+</span><br><span class="line">例如给定上述表格，你的查询应返回：</span><br><span class="line"></span><br><span class="line">+-----------+</span><br><span class="line">| Customers |</span><br><span class="line">+-----------+</span><br><span class="line">| Henry     |</span><br><span class="line">| Max       |</span><br><span class="line">+-----------+</span><br></pre></td></tr></table></figure><p>贼娃子 。先找订购的就行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Name Customers <span class="keyword">from</span> Customers</span><br><span class="line"><span class="keyword">where</span> id <span class="keyword">not</span> <span class="keyword">in</span>(</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> CustomerId </span><br><span class="line"><span class="keyword">from</span> Orders</span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr><p>196.删除重复的电子邮箱</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">编写一个 SQL 查询，来删除 Person 表中所有重复的电子邮箱，重复的邮箱里只保留 Id 最小 的那个。</span><br><span class="line"></span><br><span class="line">+----+------------------+</span><br><span class="line">| Id | Email            |</span><br><span class="line">+----+------------------+</span><br><span class="line">| 1  | john@example.com |</span><br><span class="line">| 2  | bob@example.com  |</span><br><span class="line">| 3  | john@example.com |</span><br><span class="line">+----+------------------+</span><br><span class="line">Id 是这个表的主键。</span><br><span class="line">例如，在运行你的查询语句之后，上面的 Person 表应返回以下几行:</span><br><span class="line"></span><br><span class="line">+----+------------------+</span><br><span class="line">| Id | Email            |</span><br><span class="line">+----+------------------+</span><br><span class="line">| 1  | john@example.com |</span><br><span class="line">| 2  | bob@example.com  |</span><br><span class="line">+----+------------------+</span><br></pre></td></tr></table></figure><p>又是一个漂亮的自连接 删除Email相同id大的那个</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> p1 <span class="keyword">FROM</span> Person p1,</span><br><span class="line">    Person p2</span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">    p1.Email <span class="operator">=</span> p2.Email <span class="keyword">AND</span> p1.Id <span class="operator">&gt;</span> p2.Id</span><br></pre></td></tr></table></figure><p>不行 sql写着写着犯困 得做些别的事</p><hr><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">表 Weather</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Column</span> Name   <span class="operator">|</span> Type    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+---------+</span></span><br><span class="line"><span class="operator">|</span> id            <span class="operator">|</span> <span class="type">int</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> recordDate    <span class="operator">|</span> <span class="type">date</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> temperature   <span class="operator">|</span> <span class="type">int</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+---------+</span></span><br><span class="line">id 是这个表的主键</span><br><span class="line">该表包含特定日期的温度信息</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">编写一个 <span class="keyword">SQL</span> 查询，来查找与之前（昨天的）日期相比温度更高的所有日期的 id 。</span><br><span class="line"></span><br><span class="line">返回结果 不要求顺序 。</span><br><span class="line"></span><br><span class="line">查询结果格式如下例：</span><br><span class="line"></span><br><span class="line">Weather</span><br><span class="line"><span class="operator">+</span><span class="comment">----+------------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> recordDate <span class="operator">|</span> Temperature <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------------+-------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> <span class="number">2015</span><span class="number">-01</span><span class="number">-01</span> <span class="operator">|</span> <span class="number">10</span>          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span>  <span class="operator">|</span> <span class="number">2015</span><span class="number">-01</span><span class="number">-02</span> <span class="operator">|</span> <span class="number">25</span>          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span>  <span class="operator">|</span> <span class="number">2015</span><span class="number">-01</span><span class="number">-03</span> <span class="operator">|</span> <span class="number">20</span>          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">4</span>  <span class="operator">|</span> <span class="number">2015</span><span class="number">-01</span><span class="number">-04</span> <span class="operator">|</span> <span class="number">30</span>          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------------+-------------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Result</span> <span class="keyword">table</span>:</span><br><span class="line"><span class="operator">+</span><span class="comment">----+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">4</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+</span></span><br><span class="line"><span class="number">2015</span><span class="number">-01</span><span class="number">-02</span> 的温度比前一天高（<span class="number">10</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">25</span>）</span><br><span class="line"><span class="number">2015</span><span class="number">-01</span><span class="number">-04</span> 的温度比前一天高（<span class="number">20</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">30</span>）</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    weather.id <span class="keyword">AS</span> <span class="string">&#x27;Id&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    weather</span><br><span class="line">        <span class="keyword">JOIN</span></span><br><span class="line">    weather w <span class="keyword">ON</span> DATEDIFF(weather.recordDate, w.recordDate) <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">AND</span> weather.Temperature <span class="operator">&gt;</span> w.Temperature</span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>真不写了 疯狂走神。</p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;收录一些比较有意思的sql题，纯粹图一乐&lt;/p&gt;</summary>
    
    
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-位运算</title>
    <link href="http://example.com/2020/12/28/LEETCODE-%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://example.com/2020/12/28/LEETCODE-%E4%BD%8D%E8%BF%90%E7%AE%97/</id>
    <published>2020-12-28T11:13:34.000Z</published>
    <updated>2023-05-14T13:50:41.558Z</updated>
    
    <content type="html"><![CDATA[<p>位运算感觉是个坑…你不会吧，你就完全不会了。你懂了会做相关的题了。</p><a id="more"></a> <p>常用操作    </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X &amp; <span class="number">1</span> == <span class="number">1</span> <span class="keyword">or</span> ==<span class="number">0</span> 判断奇偶</span><br><span class="line">X = X&amp;(X-1) =&gt; 清除最低位的1</span><br><span class="line">X&amp;-X =&gt; 得到最低位的1</span><br></pre></td></tr></table></figure><p>LEETCODE191.统计1的个数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        count=<span class="number">0</span></span><br><span class="line">        x=n</span><br><span class="line">        <span class="keyword">while</span> x!=<span class="number">0</span>:</span><br><span class="line">            x=x&amp;(x-<span class="number">1</span>)</span><br><span class="line">            count+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p>LEETCODE231 2的幂</p><p>2的幂只有0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPowerOfTwo</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="comment"># 2的幂只要 0 1</span></span><br><span class="line">        <span class="comment">#  -1 </span></span><br><span class="line">        <span class="keyword">return</span> n&gt;<span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span>(n &amp; n-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拆开来更好一些    </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPowerOfTwo</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="comment"># 2的幂只要 0 1</span></span><br><span class="line">        <span class="comment">#  -1 </span></span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">0</span>:<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> n&amp;(n-<span class="number">1</span>)==<span class="number">0</span>:<span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>LEETCODE338. 比特位计数</p><blockquote><p>给定一个非负整数 <strong>num</strong>。对于 <strong>0 ≤ i ≤ num</strong> 范围中的每个数字 <strong>i</strong> ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p></blockquote><p>答案挺有意思的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countBits</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        </span><br><span class="line">        count_list =[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,num+<span class="number">1</span>):</span><br><span class="line">            count_list[i]=count_list[i&amp;(i-<span class="number">1</span>)]+<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count_list</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;位运算感觉是个坑…你不会吧，你就完全不会了。你懂了会做相关的题了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-打家劫舍问题</title>
    <link href="http://example.com/2020/12/28/LEETCODE-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2020/12/28/LEETCODE-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E9%97%AE%E9%A2%98/</id>
    <published>2020-12-28T11:13:10.000Z</published>
    <updated>2023-05-14T13:50:41.559Z</updated>
    
    <content type="html"><![CDATA[<p>打家劫舍问题~</p><a id="more"></a><p>LEECODE198.打家劫舍1</p><blockquote><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p></blockquote><p>大体思路:这个问题描述很好玩，但核心就是不能搞相邻的。</p><p>所以核心状态转移方程的话就是:<code>max(dp[i-2]+nums[i],dp[i-1])</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># dp数组的定义很重要就是打劫前n家的最大收入</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">1</span>:<span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>LEECODE213.打家劫舍2</p><blockquote><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额。</p></blockquote><p>和上一题相比 ，多了一个头尾相连 就仅仅多了一个条件</p><p>如果等于2 那就抢不得 但是显然没有那么简单</p><p>太妙了！！ 把他拆解成 不包含头 和不包含尾 然后取一个最大值 鬼才啊</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">1</span>:<span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">0</span>:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(self.rob1(nums[<span class="number">1</span>:]),self.rob1(nums[:-<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob1</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># dp数组的定义很重要就是打劫前n家的最大收入</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">1</span>:<span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>LEETCODE.337 打家劫舍3</p><blockquote><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p></blockquote><p>打劫二叉树是我万万没有想到的。好家伙</p><p>我们可以用 f(o)f(o) 表示选择 oo 节点的情况下，oo 节点的子树上被选择的节点的最大权值和；g(o)g(o) 表示不选择 oo 节点的情况下，oo 节点的子树上被选择的节点的最大权值和；ll 和 rr 代表 oo 的左右孩子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map &lt;TreeNode*, <span class="keyword">int</span>&gt; f, g;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!o) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(o-&gt;left);</span><br><span class="line">        <span class="built_in">dfs</span>(o-&gt;right);</span><br><span class="line">      # 如果选了root 就不能选左右孩子。</span><br><span class="line">      # 如果没选root 就是选左 或者选右 的最大值。</span><br><span class="line">      # 看着还挺麻烦的。。</span><br><span class="line">      </span><br><span class="line">        f[o] = o-&gt;val + g[o-&gt;left] + g[o-&gt;right];</span><br><span class="line">        g[o] = <span class="built_in">max</span>(f[o-&gt;left], g[o-&gt;left]) + <span class="built_in">max</span>(f[o-&gt;right], g[o-&gt;right]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* o)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(o);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(f[o], g[o]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;打家劫舍问题~&lt;/p&gt;</summary>
    
    
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-股票问题</title>
    <link href="http://example.com/2020/12/28/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2020/12/28/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/</id>
    <published>2020-12-28T01:33:21.000Z</published>
    <updated>2023-05-14T13:50:41.564Z</updated>
    
    <content type="html"><![CDATA[<p>股票问题还挺有意思的</p><a id="more"></a> <p>[toc]</p><p>总共六道题</p><blockquote><p>1笔交易  dp第二维有三个状态。这轮啥也不干 这轮买入 这轮卖出</p><p>n笔交易 dp第二维有两个状态。这轮持有股票 这轮没有持有股票</p><p>n笔交易 也是是否持有股票</p></blockquote><h4 id="LEECODE121-买卖股票的最佳时期"><a href="#LEECODE121-买卖股票的最佳时期" class="headerlink" title="LEECODE121.买卖股票的最佳时期"></a>LEECODE121.买卖股票的最佳时期</h4><p>这题就是只能完成1笔交易</p><blockquote><p>大体思路这两道简单题就是只要把dp数组定义好，思路就特别清晰了。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">      <span class="comment">#此轮啥也不干</span></span><br><span class="line">      dp[[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]<span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">      dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">      <span class="comment">#此轮买入股票</span></span><br><span class="line">      dp[<span class="number">0</span>][<span class="number">1</span>]=(-<span class="number">1</span>)*prices[<span class="number">0</span>]</span><br><span class="line">      <span class="comment">#此轮卖出股票</span></span><br><span class="line">      dp[<span class="number">0</span>][<span class="number">2</span>]=<span class="number">0</span></span><br><span class="line">      ans=<span class="number">0</span></span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        dp[i][<span class="number">0</span>]=dp[i-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        dp[i][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]-prices[i])</span><br><span class="line">        dp[i][<span class="number">2</span>]=dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i]</span><br><span class="line">      ans = <span class="built_in">max</span>(dp[i][<span class="number">0</span>], dp[i][<span class="number">1</span>],dp[i][<span class="number">2</span>])</span><br><span class="line">      <span class="keyword">return</span> ans</span><br><span class="line">    </span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        inf = <span class="built_in">int</span>(<span class="number">1e9</span>)</span><br><span class="line">        minprice = inf</span><br><span class="line">        maxprofit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">            maxprofit = <span class="built_in">max</span>(price - minprice, maxprofit)</span><br><span class="line">            minprice = <span class="built_in">min</span>(price, minprice)</span><br><span class="line">        <span class="keyword">return</span> maxprofit</span><br></pre></td></tr></table></figure><p>这样明显简洁多了</p><hr><h4 id="LEECODE122-买卖股票的最佳时期-完成任意笔交易"><a href="#LEECODE122-买卖股票的最佳时期-完成任意笔交易" class="headerlink" title="LEECODE122.买卖股票的最佳时期 (完成任意笔交易)"></a>LEECODE122.买卖股票的最佳时期 (完成任意笔交易)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">int</span> maxProfit(vector&lt;<span class="built_in">int</span>&gt;&amp; prices) &#123;</span><br><span class="line">      <span class="built_in">int</span> n= prices.size();</span><br><span class="line">      <span class="comment"># 此轮没有股票 此轮持有股票</span></span><br><span class="line">      <span class="keyword">in</span> dp[n][<span class="number">2</span>];</span><br><span class="line">      dp[<span class="number">0</span>][<span class="number">0</span>]= <span class="number">0</span>,dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment"># 这轮持有</span></span><br><span class="line">      dp[i][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">        dp[i][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[n-<span class="number">1</span>][<span class="number">0</span>];</span><br></pre></td></tr></table></figure><hr><p>前面两题还算简单。</p><p>下面上点强度嗷。</p><p>123 309 188 714</p><hr><h4 id="123-只能完成两笔交易"><a href="#123-只能完成两笔交易" class="headerlink" title="123(只能完成两笔交易)"></a>123(只能完成两笔交易)</h4><p>k=2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">profit[i][j][k]</span><br><span class="line">k是否持有股票 <span class="number">0</span> <span class="number">1</span></span><br><span class="line">j交易了多少次 <span class="number">0</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line">i第i天</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h4 id="309-有冷却"><a href="#309-有冷却" class="headerlink" title="309(有冷却)"></a>309(有冷却)</h4><hr><h4 id="188-最多进行k笔交易"><a href="#188-最多进行k笔交易" class="headerlink" title="188(最多进行k笔交易)"></a>188(最多进行k笔交易)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mp[i][j][k]</span><br><span class="line">i 第i天</span><br><span class="line">j 是否持有股票</span><br><span class="line">k 总共交易次数 注意这个交易次数 完成交易才算一次</span><br><span class="line"><span class="comment">#这一天卖的 或者前面卖的</span></span><br><span class="line"><span class="comment"># 先列状态转移方程</span></span><br><span class="line"><span class="comment"># 完成k-1笔 然后这笔卖出</span></span><br><span class="line"><span class="comment"># 完成k-1笔 然后现在买入</span></span><br><span class="line">mp[i][k][<span class="number">0</span>]= <span class="built_in">max</span>(mp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">1</span>]+prices[i],mp[i-<span class="number">1</span>][k][<span class="number">0</span>])</span><br><span class="line">mp[i][k][<span class="number">1</span>]= <span class="built_in">max</span>(mp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>]-prices[i],mp[i-<span class="number">1</span>][k][<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">max</span>(mp[n-<span class="number">1</span>][<span class="number">0</span>~k][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># k 改为 0 1 表示是否冷却</span></span><br></pre></td></tr></table></figure><hr><h4 id="714-交易手续费"><a href="#714-交易手续费" class="headerlink" title="714(交易手续费)"></a>714(交易手续费)</h4><hr><h4 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h4><p><a href="https://time.geekbang.org/course/detail/100019701-72545">覃超算法面试通关40讲</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;股票问题还挺有意思的&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Leetcode 题型总结</title>
    <link href="http://example.com/2020/12/25/%E5%88%B7%E9%A2%98/"/>
    <id>http://example.com/2020/12/25/%E5%88%B7%E9%A2%98/</id>
    <published>2020-12-25T09:30:03.000Z</published>
    <updated>2023-05-14T13:50:41.563Z</updated>
    
    <content type="html"><![CDATA[<p>总结</p><a id="more"></a> <p>[toc]</p><p><a href="https://img-blog.csdnimg.cn/2020121721064966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzdG9uZTE=,size_16,color_FFFFFF,t_70">https://img-blog.csdnimg.cn/2020121721064966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzdG9uZTE=,size_16,color_FFFFFF,t_70</a></p><h5 id="Leetcode3-无重复的最长子串"><a href="#Leetcode3-无重复的最长子串" class="headerlink" title="Leetcode3 无重复的最长子串"></a>Leetcode3 无重复的最长子串</h5><blockquote><p>这几天也写了好多遍了。发现用typora写题还行。一本质上抑制了看题解的冲动。二还可以这碎碎念..</p></blockquote><p>就是python缩进太蛋疼了</p><blockquote><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p></blockquote><p>大体思路:滑动窗口双指针,当然还可以用哈希表优化优化，有点懒得搞。还是搞搞吧。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s)==<span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        left=right=<span class="number">0</span></span><br><span class="line">        ans = <span class="built_in">float</span>(-inf)</span><br><span class="line">        <span class="keyword">while</span> right !=<span class="built_in">len</span>(s)-<span class="number">1</span>:</span><br><span class="line">            <span class="comment"># </span></span><br><span class="line">            right+=<span class="number">1</span></span><br><span class="line">            <span class="comment"># 收缩</span></span><br><span class="line">            <span class="keyword">while</span> s[right] <span class="keyword">in</span> s[left:right]:</span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">            ans =<span class="built_in">max</span>(ans,right-left+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">        </span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:<span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s)==<span class="number">1</span>:<span class="keyword">return</span> <span class="number">1</span> </span><br><span class="line">        left=right =<span class="number">0</span></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        window=&#123;&#125;</span><br><span class="line">        <span class="keyword">while</span> right!=<span class="built_in">len</span>(s):</span><br><span class="line">            c=s[right]</span><br><span class="line">            right+=<span class="number">1</span></span><br><span class="line">            window[c]=window.get(c,<span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> window[c]&gt;<span class="number">1</span>:</span><br><span class="line">                d = s[left]</span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">                window[d]-=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            ret= <span class="built_in">max</span>(ret,right-left)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><p>好像也没优化到哪去，反而代码还复杂了…</p><h5 id="LEETCODE25-K个一组翻转链表"><a href="#LEETCODE25-K个一组翻转链表" class="headerlink" title="LEETCODE25.K个一组翻转链表"></a>LEETCODE25.K个一组翻转链表</h5><p>有时间再写吧…</p><p>重写 已经忘的差不多了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums: [<span class="built_in">int</span>]</span>) -&gt; [[<span class="built_in">int</span>]]:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        res, k = [], <span class="number">0</span></span><br><span class="line">        <span class="comment"># 操作都在循环里面</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]: <span class="keyword">continue</span></span><br><span class="line">            j, k = i + <span class="number">1</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; k:</span><br><span class="line">                s = nums[i] + nums[j] + nums[k]</span><br><span class="line">                <span class="keyword">if</span> s &lt; <span class="number">0</span>:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[j] == nums[j - <span class="number">1</span>]: j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> s &gt; <span class="number">0</span>:</span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[k] == nums[k + <span class="number">1</span>]: k -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append([nums[k], nums[i], nums[j]])</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[j] == nums[j - <span class="number">1</span>]: j += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[k] == nums[k + <span class="number">1</span>]: k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h5 id="LEETCODE15-三数之和"><a href="#LEETCODE15-三数之和" class="headerlink" title="LEETCODE15.三数之和"></a>LEETCODE15.三数之和</h5><blockquote><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p></blockquote><p>大体思路就是先排个序 然后一个for循环 接双指针 麻烦点在于不重复 还有可以跳过的情况</p><p>去重的问题忘了咋解决了.. 去重的代码有四处，太逆天了…</p><p>后面的代码倒也能够理解 。看一看与下面一个值是否相同，相同直接跳</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums: [<span class="built_in">int</span>]</span>) -&gt; [[<span class="built_in">int</span>]]:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        res, k = [], <span class="number">0</span></span><br><span class="line">        <span class="comment"># 操作都在循环里面</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]: <span class="keyword">continue</span></span><br><span class="line">            j, k = i + <span class="number">1</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; k:</span><br><span class="line">                s = nums[i] + nums[j] + nums[k]</span><br><span class="line">                <span class="keyword">if</span> s &lt; <span class="number">0</span>:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[j] == nums[j - <span class="number">1</span>]: j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> s &gt; <span class="number">0</span>:</span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[k] == nums[k + <span class="number">1</span>]: k -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append([nums[k], nums[i], nums[j]])</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[j] == nums[j - <span class="number">1</span>]: j += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[k] == nums[k + <span class="number">1</span>]: k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">      </span><br><span class="line">     </span><br></pre></td></tr></table></figure><p>果然还是要自己写一遍 自己写一遍就发现错误百出</p><h5 id="LEETCODE42-接雨水"><a href="#LEETCODE42-接雨水" class="headerlink" title="LEETCODE42.接雨水"></a>LEETCODE42.接雨水</h5><blockquote><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p></blockquote><p>经典题目。思路就是按列遍历 左边找最高的，左边找最高的 如果低于当前高度。那么这一格就集不到水。然后又根据木桶效应。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">      ans=<span class="number">0</span></span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(height)-<span class="number">1</span>):</span><br><span class="line">          left_max=<span class="built_in">max</span>(height[:i])</span><br><span class="line">          right_max=<span class="built_in">max</span>(height[i+<span class="number">1</span>:])</span><br><span class="line">          <span class="keyword">if</span> left_max&lt;height[i] <span class="keyword">or</span> right_max&lt;height[i]:<span class="keyword">continue</span></span><br><span class="line">          ans += <span class="built_in">min</span>(left_max,right_max)</span><br><span class="line">      <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>这么看这代码满打满算才10行</p><h5 id="LEETCODE415-字符串相加"><a href="#LEETCODE415-字符串相加" class="headerlink" title="LEETCODE415.字符串相加"></a>LEETCODE415.字符串相加</h5><p>给定两个字符串形式的非负整数 <code>num1</code> 和<code>num2</code> ，计算它们的和。</p><ol><li><strong>你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式</strong></li></ol><p>但是可以int()其中的字符..</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addStrings</span>(<span class="params">self, num1: <span class="built_in">str</span>, num2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        i=<span class="built_in">len</span>(num1)-<span class="number">1</span></span><br><span class="line">        j=<span class="built_in">len</span>(num2)-<span class="number">1</span></span><br><span class="line">        carry=<span class="number">0</span></span><br><span class="line">        ans=<span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> i&gt;=<span class="number">0</span> <span class="keyword">or</span> j&gt;=<span class="number">0</span>:</span><br><span class="line">            n1 = <span class="built_in">int</span>(num1[i]) <span class="keyword">if</span> i&gt;=<span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            n2 = <span class="built_in">int</span>(num2[j]) <span class="keyword">if</span> j&gt;=<span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            tmp = n1+n2+carry</span><br><span class="line">            carry = tmp//<span class="number">10</span></span><br><span class="line">            ans = <span class="built_in">str</span>(tmp%<span class="number">10</span>)+ans</span><br><span class="line">            i-=<span class="number">1</span></span><br><span class="line">            j-=<span class="number">1</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>+ ans <span class="keyword">if</span> carry <span class="keyword">else</span> ans</span><br><span class="line">        </span><br></pre></td></tr></table></figure><p>这题还挺有意思的</p><h5 id="LEETCODE103-二叉树的锯齿层次遍历"><a href="#LEETCODE103-二叉树的锯齿层次遍历" class="headerlink" title="LEETCODE103.二叉树的锯齿层次遍历"></a>LEETCODE103.二叉树的锯齿层次遍历</h5><blockquote><p>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p></blockquote><p>大体思路:</p><p>先完成层次遍历再加一个flag?</p><p>flag只控制加入temp_list的顺序…跟我理解的题意不太一样。其实这样感觉可以逆转一下也一样的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    def zigzagLevelOrder(self, root: TreeNode) -&gt; List[List[int]]:</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> []</span><br><span class="line">        flag=<span class="number">1</span></span><br><span class="line">        temp = collections.<span class="built_in">deque</span>()</span><br><span class="line">        temp.<span class="built_in">append</span>(root)</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(temp)!=<span class="number">0</span>:</span><br><span class="line">            n = <span class="built_in">len</span>(temp)</span><br><span class="line">            temp_list=collections.<span class="built_in">deque</span>()</span><br><span class="line">            <span class="keyword">for</span> i in <span class="built_in">range</span>(n):</span><br><span class="line">                node = temp.<span class="built_in">popleft</span>()</span><br><span class="line">                <span class="comment">//就记住这个flag就行</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="keyword">if</span> flag==<span class="number">1</span>:</span><br><span class="line">                    temp_list.<span class="built_in">append</span>(node.val)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    temp_list.<span class="built_in">appendleft</span>(node.val)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> node.left!=None:temp.<span class="built_in">append</span>(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right!=None:temp.<span class="built_in">append</span>(node.right)            </span><br><span class="line"></span><br><span class="line">            flag=(<span class="number">-1</span>)*flag</span><br><span class="line">            ans.<span class="built_in">append</span>(<span class="built_in">list</span>(temp_list))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><hr><h5 id="LEETCODE-121-买卖股票的最佳时机"><a href="#LEETCODE-121-买卖股票的最佳时机" class="headerlink" title="LEETCODE.121 买卖股票的最佳时机"></a>LEETCODE.121 买卖股票的最佳时机</h5><blockquote><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p><p>注意：你不能在买入股票前卖出股票。</p></blockquote><p>这题是真的经典 覃超这个讲的真的挺明白的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        dp=[[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 0代表手上没有股票 1代码手上有股票 2代码卖出股票</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=-price[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>]=<span class="number">0</span></span><br><span class="line">       ans =<span class="number">0</span> </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">        dp[i][<span class="number">0</span>]=dp[i-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">          dp[i][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]-price[i])</span><br><span class="line">          dp[i][<span class="number">2</span>]=dp[i-<span class="number">1</span>][<span class="number">1</span>]+price[i]</span><br><span class="line">          ans = <span class="built_in">max</span>(ans,dp[i][<span class="number">0</span>],dp[i][<span class="number">1</span>],dp[i][<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><hr><h5 id="Leetcode124-二叉树的最大路径和"><a href="#Leetcode124-二叉树的最大路径和" class="headerlink" title="Leetcode124.二叉树的最大路径和"></a>Leetcode124.二叉树的最大路径和</h5><blockquote><p> 给定一个非空二叉树，返回其最大路径和。本题中，路径被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</p></blockquote><p>不是很能理解</p><p>好像大概又能理解了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.maxSum = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPathSum</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">maxGain</span>(<span class="params">node</span>)-&gt;<span class="built_in">int</span>:</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> node:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">          </span><br><span class="line">          left=<span class="built_in">max</span>(<span class="number">0</span>,maxGain(root.left))</span><br><span class="line">          right=<span class="built_in">max</span>(<span class="number">0</span>,maxGain(root.right))</span><br><span class="line">          </span><br><span class="line">priceNew = root.val +left + right</span><br><span class="line">          self.maxSum=<span class="built_in">max</span>(self.maxSum,spriceNew</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> node.val+<span class="built_in">max</span>(left,right)</span><br><span class="line">        </span><br><span class="line">        maxGain(root)</span><br><span class="line">        <span class="keyword">return</span> self.maxSum</span><br></pre></td></tr></table></figure><h5 id="LEECODE31-下一个排列"><a href="#LEECODE31-下一个排列" class="headerlink" title="LEECODE31.下一个排列"></a>LEECODE31.下一个排列</h5><blockquote><p>实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须 原地 修改，只允许使用额外常数空间。</p></blockquote><p>今天想办法搞定。</p><p>先试着理解题意吧。举几个例子看看。</p><p>1-&gt;2-&gt;4-&gt;5,这一段是升序的，也就是5421已经是最大数，不存在比它大的组合，</p><p>递增这样的就是字典序最大 。因为啥呢。反正就是和真实大小相反。</p><p>这个题目本身不难，关键是理解题意，我们以一个例子来分析，给定325421，求其下一个比它大的数，怎么办呢？我们应该从最低位开始，1-&gt;2-&gt;4-&gt;5,这一段是升序的，也就是5421已经是最大数，不存在比它大的组合，我们继续找，1-&gt;2-&gt;4-&gt;5-&gt;2，出现降序这个位置就是我们要找的关键点，只需要将2与其后的数字中的（1,2,4,5）<strong>比它大的最小数</strong>，也就4替换，<strong>然后再将后面的数</strong>（1,2,2,5）升序排列便可得到下一个数，过程为：325421-&gt;345221-&gt;345122</p><p>找反向遍历第一个降序点 2 之后的数字</p><p>从后往前找到比一个数字大的数</p><p>找到后和后面比它大的最小数交换</p><p>换完后排序</p><p>这样就清晰多了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> keyIndex=nums.<span class="built_in">size</span>()<span class="number">-1</span>;<span class="comment">//指向最后一个数</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//比前一个数字大</span></span><br><span class="line"><span class="keyword">while</span>(keyIndex&gt;<span class="number">0</span>&amp;&amp;nums.<span class="built_in">at</span>(keyIndex)&lt;=nums.<span class="built_in">at</span>(keyIndex<span class="number">-1</span>))</span><br><span class="line">keyIndex--;<span class="comment">//寻找降序关键点</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(keyIndex==<span class="number">0</span>)<span class="comment">//如果关键点下标为0，则原数据排列为全降序，不存在比它更大的数，将原排列升序重排</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> minNum=nums[keyIndex<span class="number">-1</span>];<span class="comment">//关键点下标对应的待替换数字</span></span><br><span class="line">      <span class="comment">//因为是升序所以直接找</span></span><br><span class="line">      <span class="comment">//找到比它最大最小那个 对那的确就是反向找</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=nums.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;keyIndex<span class="number">-1</span>;i--)<span class="comment">//寻找关键点后最小的且大于待替换数字的数据对应的下标</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(nums[i]&gt;minNum)<span class="comment">//找到，则替换</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line">temp=nums[i];</span><br><span class="line">nums[i]=nums[keyIndex<span class="number">-1</span>];</span><br><span class="line">nums[keyIndex<span class="number">-1</span>]=temp;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>()+keyIndex,nums.<span class="built_in">end</span>());<span class="comment">//将替换后，关键点后的数据进行升序重排</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">看题解都看的不是很明白 </span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h5 id="LEETCODE143-重排链表"><a href="#LEETCODE143-重排链表" class="headerlink" title="LEETCODE143.重排链表"></a>LEETCODE143.重排链表</h5><blockquote><p>给定一个单链表 L：L0→L1→…→Ln-1→Ln ，<br>将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p></blockquote><p>这题挺有意思的。</p><p>两个思路 一个是像这样的用数组存</p><p>第二个是 找中点 + 反转 后半部分 + merge </p><p>显然前一个比后一个简单太多了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reorderList</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify head in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:<span class="keyword">return</span> head</span><br><span class="line">        vec=[]</span><br><span class="line">        cur =head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            vec.append(cur)</span><br><span class="line">            cur=cur.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        j=<span class="built_in">len</span>(vec)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;j:</span><br><span class="line">            vec[i].<span class="built_in">next</span>=vec[j]</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i==j:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            vec[j].<span class="built_in">next</span>=vec[i]</span><br><span class="line">            j-=<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        vec[j].<span class="built_in">next</span>=<span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><hr><p>第一次面试的题 现在才解出来。那时候的确没法写出回溯来。</p><blockquote><p>给定一个int数组A，给定一个数x，求所有求和能得到x的数字组合，组合中的元素来自A</p></blockquote><p>解回溯的题 感觉最重要的是遍历 只要我能遍历到所有的tmp 那么就一定能找到答案。</p><p>然后再加上一些剪枝。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">self.res=[]</span><br><span class="line">self.tmp=[]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSetOfSum</span>(<span class="params">self,nums:<span class="type">List</span>[<span class="built_in">int</span>],target</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> nums:<span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recur</span>(<span class="params">nums:<span class="type">List</span>[<span class="built_in">int</span>],target:<span class="built_in">int</span>,index:<span class="built_in">int</span></span>):</span></span><br><span class="line"><span class="keyword">if</span> target&lt;<span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> target==<span class="number">0</span>:</span><br><span class="line">self.res.append(self.tmp[:])</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index,<span class="built_in">len</span>(nums)-<span class="number">1</span>):</span><br><span class="line">self.tmp.append(nums[i])</span><br><span class="line">recur(nums,target-nums[i],i)</span><br><span class="line">self.tmp.pop()</span><br><span class="line"></span><br><span class="line">recur(nums,target,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">a = Solution()</span><br><span class="line">result = a.getSetOfSum([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><hr><h5 id="LEETCODE105-重建二叉树"><a href="#LEETCODE105-重建二叉树" class="headerlink" title="LEETCODE105.重建二叉树"></a>LEETCODE105.重建二叉树</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Create</span>(<span class="number">0</span>,preorder.<span class="built_in">size</span>()<span class="number">-1</span>,<span class="number">0</span>,inorder.<span class="built_in">size</span>()<span class="number">-1</span>,preorder,inorder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先序 根左右</span></span><br><span class="line">    <span class="comment">// 中序 左根右</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">Create</span><span class="params">(<span class="keyword">int</span> preL,<span class="keyword">int</span> preR,<span class="keyword">int</span> inL,<span class="keyword">int</span> inR,vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preL&gt;preR)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        TreeNode * root =<span class="keyword">new</span> TreeNode;</span><br><span class="line">        root-&gt;val=preorder[preL];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//先序的第一个就是根节点 保留根节点</span></span><br><span class="line">        <span class="comment">//想一想后序怎么写好吧</span></span><br><span class="line">        <span class="comment">//左右根</span></span><br><span class="line">        <span class="comment">//左根右</span></span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;<span class="comment">//保存根节点在中序里的下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =inL;i&lt;=inR;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;val==inorder[i])&#123;</span><br><span class="line">                k=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左子树长度</span></span><br><span class="line">        <span class="keyword">int</span> left_tree_length = k-inL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//思路还是很清晰的 之前一直没绕过这个弯</span></span><br><span class="line">        root-&gt;left = <span class="built_in">Create</span>(preL+<span class="number">1</span>,preL+left_tree_length,inL,k<span class="number">-1</span>,preorder,inorder);</span><br><span class="line">        root-&gt;right = <span class="built_in">Create</span>(preL+left_tree_length+<span class="number">1</span>,preR,k+<span class="number">1</span>,inR,preorder,inorder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>果然代码要自己写一遍才是自己的。</p><p>边界问题还是挺多问题的。</p><p>1.preL+k–inL 2.还有size()-1 3.还有Treenode *root = new TreeNode</p><p>踩了三个坑。</p><hr><p>move on move on</p><hr><h5 id="LEETCODE206-反转链表"><a href="#LEETCODE206-反转链表" class="headerlink" title="LEETCODE206.反转链表"></a>LEETCODE206.反转链表</h5><p>直接条件反射</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">     <span class="keyword">if</span> <span class="keyword">not</span> head:<span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        prev=<span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">          next_p=head.<span class="built_in">next</span></span><br><span class="line">          <span class="comment"># 条件反射还是能写出bug</span></span><br><span class="line">          </span><br><span class="line">          head.<span class="built_in">next</span>=prev</span><br><span class="line">          </span><br><span class="line">          prev=head</span><br><span class="line">          head=next_p</span><br><span class="line">       <span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure><h5 id="LEETCODE1-两数之和"><a href="#LEETCODE1-两数之和" class="headerlink" title="LEETCODE1.两数之和"></a>LEETCODE1.两数之和</h5><p>写了这么多遍还是容易忘</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">  <span class="comment"># key 是num value 是index</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    hashtable=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> index,value <span class="keyword">in</span> emumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> target-value <span class="keyword">in</span> hashtable:</span><br><span class="line">              <span class="keyword">return</span> [index,hashtable[target-num]]</span><br><span class="line">            hashtable[value]=index</span><br><span class="line">       <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><h5 id="LEETCODE199-二叉树的右视图"><a href="#LEETCODE199-二叉树的右视图" class="headerlink" title="LEETCODE199.二叉树的右视图"></a>LEETCODE199.二叉树的右视图</h5><blockquote><p>最近才写的应该</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">      <span class="comment">#懒得写了...</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> []</span><br><span class="line">        ans=[]</span><br><span class="line">        <span class="comment">#ans.append(root.val)</span></span><br><span class="line">        queue=[root]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">          n = <span class="built_in">len</span>(queue)</span><br><span class="line">          ans.append(queue[-<span class="number">1</span>].val)</span><br><span class="line">          <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,n):</span><br><span class="line">             node = queue.pop()</span><br><span class="line">             <span class="keyword">if</span> root.left:queue.append(root.left)</span><br><span class="line">             <span class="keyword">if</span> root.right:queue.append(root.right)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">        </span><br></pre></td></tr></table></figure><p>LEETCODE160.相交链表</p><blockquote><p> 编写一个程序，找到两个单链表相交的起始节点。</p></blockquote><p>这题挺有意思的。题解太好玩了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        l1 =headA</span><br><span class="line">        L2 =headB</span><br><span class="line">        <span class="keyword">while</span> l1!=l2:</span><br><span class="line">          <span class="comment"># 相当于第一条路走到头了.</span></span><br><span class="line">           <span class="keyword">if</span> l1==<span class="literal">None</span>:</span><br><span class="line">                l1=headB</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l1=l1.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> l2==<span class="literal">None</span>:</span><br><span class="line">                l2=headA</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l2=l2.<span class="built_in">next</span>     </span><br><span class="line">        <span class="keyword">return</span> l1</span><br></pre></td></tr></table></figure><h5 id="LEETCODE215-数组中第K个最大元素-原来这就是topK"><a href="#LEETCODE215-数组中第K个最大元素-原来这就是topK" class="headerlink" title="LEETCODE215.数组中第K个最大元素 原来这就是topK"></a>LEETCODE215.数组中第K个最大元素 原来这就是topK</h5><blockquote><p>在未排序的数组中找到第 <strong>k</strong> 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p></blockquote><p>大体思路:直接奔着题解去了~方法一：基于快速排序的选择方法 方法二：基于堆排序的选择方法</p><p>所以这个题目 排个序就完了</p><p>堆排 然后调用K次？建堆 然后调用K次 </p><p>今天下午尽量就是解决堆排和快排的问题</p><p>堆的话就是大顶堆</p><p>我有点不太清楚大顶堆和二叉树搜索树区别</p><p>大顶堆只能保证根是最大的？但是不保证左右。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp= arr[i];</span><br><span class="line">arr[i]=arr[j];</span><br><span class="line">arr[j]=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span> tree[],<span class="keyword">int</span> n,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i&gt;=n)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> c1 = <span class="number">2</span>*i +<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> c2 = <span class="number">2</span>*i +<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> maxIndex=i;</span><br><span class="line"><span class="keyword">if</span> (c1&lt; n &amp;&amp; tree[c1]&gt;tree[maxIndex])&#123;</span><br><span class="line">maxIndex =c1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (c2&lt; n &amp;&amp; tree[c2]&gt;tree[maxIndex])&#123;</span><br><span class="line">maxIndex =c2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (maxIndex!=i)&#123;</span><br><span class="line">swap(tree,maxIndex,i);</span><br><span class="line">heapify(tree,n,maxIndex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_heap</span><span class="params">(<span class="keyword">int</span> tree[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> last_node=n<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> parent=(last_node<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=parent;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">heapify(tree,n,i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="keyword">int</span> tree[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">build_heap(tree,n);</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">swap(tree,i,<span class="number">0</span>);</span><br><span class="line">heapify(tree,i,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//大的被交换到尾巴去了 太有意思了堆排</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    heap_sort(nums,numsSize);</span><br><span class="line">    <span class="keyword">return</span> nums[numsSize-k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是快排</p><p>先回忆一下快排 两个哨兵找 然后交换 一直到相遇 相遇了就可以再交换。找到temp的位置了说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = left, j = right, temp = arr[left], t;</span><br><span class="line">        <span class="keyword">while</span> (i != j) &#123;</span><br><span class="line">          <span class="comment">// 右边找到一个比base小的</span></span><br><span class="line">            <span class="keyword">while</span> (arr[j] &gt;= temp &amp;&amp; i &lt; j) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 左边找到一个比base大的</span></span><br><span class="line">            <span class="keyword">while</span> (arr[i] &lt;= temp &amp;&amp; i&lt;j) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//交换</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                t = arr[i];</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                arr[j] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="comment">//base交换</span></span><br><span class="line">  <span class="comment">//然后递归下去</span></span><br><span class="line">        arr[left] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">        sort(arr, left, i - <span class="number">1</span>);</span><br><span class="line">        sort(arr, i+<span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>太骚了 这个快排</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span>(<span class="params"><span class="built_in">list</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">list</span>)&lt;<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        midpivot = <span class="built_in">list</span>[<span class="number">0</span>]</span><br><span class="line">        lessbeforemidpivot = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>[<span class="number">1</span>:] <span class="keyword">if</span> i&lt;=midpivot]</span><br><span class="line">        biggerafterpivot = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>[<span class="number">1</span>:] <span class="keyword">if</span> i &gt; midpivot]</span><br><span class="line">        finallylist = quicksort(lessbeforemidpivot)+[midpivot]+quicksort(biggerafterpivot)</span><br><span class="line">        <span class="keyword">return</span> finallylist</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> quicksort([<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>])</span><br></pre></td></tr></table></figure><hr><h5 id="LEETCODE232-用栈实现队列"><a href="#LEETCODE232-用栈实现队列" class="headerlink" title="LEETCODE232.用栈实现队列"></a>LEETCODE232.用栈实现队列</h5><p>old friend 思路清晰就行        </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s2;</span><br><span class="line">    <span class="built_in">CQueue</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        s1.<span class="built_in">push</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//# 思路没问题的</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="comment">//# s2非空</span></span><br><span class="line">      <span class="keyword">if</span>(s2.<span class="built_in">size</span>()!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp= s2.<span class="built_in">top</span>();</span><br><span class="line">      s2.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="keyword">return</span> temp;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//# s2 s1 为空</span></span><br><span class="line">      <span class="keyword">if</span> (s1.<span class="built_in">size</span>()==<span class="number">0</span> <span class="keyword">and</span> s2.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      <span class="comment">//# # s1非空 s2为空</span></span><br><span class="line">      <span class="keyword">while</span> (!s1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        s2.<span class="built_in">push</span>(s1.<span class="built_in">top</span>());</span><br><span class="line">        s1.<span class="built_in">pop</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> ans =s2.<span class="built_in">top</span>();</span><br><span class="line">      s2.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CQueue* obj = new CQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;appendTail(value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;deleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h5 id="LEETCODE-146-LRU"><a href="#LEETCODE-146-LRU" class="headerlink" title="LEETCODE 146.LRU"></a>LEETCODE 146.LRU</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DLinkListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,key=<span class="number">0</span>,value=<span class="number">0</span></span>):</span></span><br><span class="line">        self.key=key</span><br><span class="line">        self.value=value</span><br><span class="line">        self.prev=<span class="literal">None</span></span><br><span class="line">        self.<span class="built_in">next</span>=<span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.cache=<span class="built_in">dict</span>()</span><br><span class="line">        <span class="comment"># 伪头伪尾</span></span><br><span class="line">        self.tail=DLinkListNode()</span><br><span class="line">        self.head=DLinkListNode()</span><br><span class="line">        self.head.<span class="built_in">next</span>=self.tail</span><br><span class="line">        self.tail.prev=self.head</span><br><span class="line">        self.capacity=capacity</span><br><span class="line">        self.size=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.cache:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        node = self.cache[key]</span><br><span class="line">        self.moveToHead(node)</span><br><span class="line">        <span class="keyword">return</span> node.value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.cache:</span><br><span class="line">            <span class="comment"># 初始化</span></span><br><span class="line">            node = DLinkListNode(key,value)</span><br><span class="line">            self.cache[key]=node</span><br><span class="line">            self.addToHead(node)</span><br><span class="line">            self.size+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.size&gt;self.capacity:</span><br><span class="line">                removed = self.removeTail()</span><br><span class="line">                <span class="comment">#pop</span></span><br><span class="line">                self.cache.pop(removed.key)</span><br><span class="line">                self.size-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node=self.cache[key]</span><br><span class="line">            node.value=value</span><br><span class="line">            self.moveToHead(node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addToHead</span>(<span class="params">self,node</span>):</span></span><br><span class="line">        <span class="comment"># o-&gt;o o-&gt;N-&gt;o</span></span><br><span class="line">        head_next = self.head.<span class="built_in">next</span></span><br><span class="line">        node.prev=self.head</span><br><span class="line">        node.<span class="built_in">next</span>=head_next</span><br><span class="line">        head_next.prev=node</span><br><span class="line">        self.head.<span class="built_in">next</span>=node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNode</span>(<span class="params">self,node</span>):</span></span><br><span class="line">        node.prev.<span class="built_in">next</span>=node.<span class="built_in">next</span></span><br><span class="line">        node.<span class="built_in">next</span>.prev=node.prev</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveToHead</span>(<span class="params">self,node</span>):</span></span><br><span class="line">        self.removeNode(node)</span><br><span class="line">        self.addToHead(node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeTail</span>(<span class="params">self</span>):</span></span><br><span class="line">        node = self.tail.prev</span><br><span class="line">        self.removeNode(node)</span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure><h5 id="LEETCODE53-最大子序和"><a href="#LEETCODE53-最大子序和" class="headerlink" title="LEETCODE53.最大子序和"></a>LEETCODE53.最大子序和</h5><blockquote><p> 给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p></blockquote><p>别说这道题要是冷不丁一来我还真接不住</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    def maxSubArray(self, nums: List[int]) -&gt; int:</span><br><span class="line">        maxSum = nums[<span class="number">0</span>]</span><br><span class="line">        curSum =nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">            curSum = <span class="built_in">max</span>(curSum+nums[i],nums[i])</span><br><span class="line">            maxSum=<span class="built_in">max</span>(maxSum,curSum)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxSum</span><br></pre></td></tr></table></figure><h5 id="LEETCODE155-最小栈"><a href="#LEETCODE155-最小栈" class="headerlink" title="LEETCODE155.最小栈"></a>LEETCODE155.最小栈</h5><blockquote><p>这个解法也挺巧妙的 。</p></blockquote><p>大体思路:之前一直扣细节。其实只要每次push 的时候栈顶和当前push一个最小的进去就行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.min_stack = [math.inf]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.stack.append(x)</span><br><span class="line">        <span class="comment"># 就这一句</span></span><br><span class="line">        self.min_stack.append(<span class="built_in">min</span>(x, self.min_stack[-<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.stack.pop()</span><br><span class="line">        self.min_stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.min_stack[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h5 id="LEETCODE20-有效的扩号"><a href="#LEETCODE20-有效的扩号" class="headerlink" title="LEETCODE20.有效的扩号"></a>LEETCODE20.有效的扩号</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        pairs = &#123;</span><br><span class="line">            <span class="string">&quot;)&quot;</span>: <span class="string">&quot;(&quot;</span>,</span><br><span class="line">            <span class="string">&quot;]&quot;</span>: <span class="string">&quot;[&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&#125;&quot;</span>: <span class="string">&quot;&#123;&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        stack = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> ch <span class="keyword">in</span> pairs:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">or</span> stack[-<span class="number">1</span>] != pairs[ch]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(ch)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> stack</span><br></pre></td></tr></table></figure><h5 id="LEETCODE141-环形链表"><a href="#LEETCODE141-环形链表" class="headerlink" title="LEETCODE141.环形链表"></a>LEETCODE141.环形链表</h5><p>大体思路:快慢指针就行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        slow = fast =head</span><br><span class="line">        <span class="keyword">while</span> slow <span class="keyword">and</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> slow <span class="keyword">is</span> fast:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h5 id="LEETCODE105-前序与中序重建二叉树"><a href="#LEETCODE105-前序与中序重建二叉树" class="headerlink" title="LEETCODE105.前序与中序重建二叉树"></a>LEETCODE105.前序与中序重建二叉树</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Rebuild</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="keyword">int</span>&gt;&amp; inorder,<span class="keyword">int</span> preL,<span class="keyword">int</span> preR,<span class="keyword">int</span> inL,<span class="keyword">int</span> inR)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preL&gt;preR)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode * root = <span class="keyword">new</span> TreeNode;</span><br><span class="line">        root-&gt;val = preorder[preL];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=inL;i&lt;=inR;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;val ==inorder[i])&#123;</span><br><span class="line">                k=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftLen= k-inL;</span><br><span class="line"></span><br><span class="line">        root-&gt;left=<span class="built_in">Rebuild</span>(preorder,inorder,preL+<span class="number">1</span>,preL+leftLen,inL,k<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right=<span class="built_in">Rebuild</span>(preorder,inorder,preL+leftLen+<span class="number">1</span>,preR,k+<span class="number">1</span>,inR);   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Rebuild</span>(preorder,inorder,<span class="number">0</span>,preorder.<span class="built_in">size</span>()<span class="number">-1</span>,<span class="number">0</span>,inorder.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>LEETCODE300.最长上升子序列</p><blockquote><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p></blockquote><p>dp题 你要我写 我不一定写的出来。就到这吧。留给明天写一写。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;总结&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>HTTP 报文结构及TCP 报文结构</title>
    <link href="http://example.com/2020/12/22/HTTP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84%E5%8F%8ATCP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2020/12/22/HTTP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84%E5%8F%8ATCP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84/</id>
    <published>2020-12-22T08:52:05.000Z</published>
    <updated>2023-05-14T13:50:41.558Z</updated>
    
    <content type="html"><![CDATA[<p>同上，是之前没回答上来的问题。</p><a id="more"></a> <p>先整一整HTTP报文结构，TCP报文结构过一遍大致能想起来。</p><p>HTTP报文是真的没啥印象了。</p><h5 id="HTTP报文结构"><a href="#HTTP报文结构" class="headerlink" title="HTTP报文结构"></a>HTTP报文结构</h5><p><strong>HTTP 协议的请求报文和响应报文的结构基本相同，由三大部分组成</strong></p><ul><li>起始行（start line）：描述请求或响应的基本信息；</li><li>头部字段集合（header）：使用 <code>key-value</code> 形式更详细地说明报文；</li><li>消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据</li></ul><p><img src="http://blog.poetries.top/img-repo/2019/12/6.png" alt="img"></p><hr><p><img src="http://blog.poetries.top/img-repo/2019/12/7.png" alt="img"></p><hr><h5 id="startline"><a href="#startline" class="headerlink" title="startline"></a>startline</h5><p>起始行 GET / 版本号</p><p><code>GET / HTTP/1.1</code></p><h5 id="header"><a href="#header" class="headerlink" title="header"></a>header</h5><p>HOST:</p><p>User-AGent:</p><p>Accept:接受的报文类型</p><p>Accept-Encoding:接受的编码格式？</p><p>Accept-language:zh-CNS</p><p>空格</p><p>数据</p><hr><p>实在是无趣啊…不搞HTTP报文结构了。</p><hr><p><img src="https://img-blog.csdn.net/20140609125220296?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTE5ODgxMDI5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>捋一下TCP报文段还是有点意思的。</p><p>首先最重要的源端口号 目的端口号</p><p>然后想一下他为了保证可靠的一些结构</p><p>拥塞控制 -&gt;窗口大小</p><p>校验和</p><p>序列号</p><p>确认号 -&gt;ACK=1 SYN=1 ack=m seq=n</p><p>SYN ACK FIN  RST </p><p>URG PSH是干啥的呢</p><p>　URG（紧急位）：设置为1时，首部中的紧急指针有效；为0时，紧急指针没有意义。</p><p>　　PSH（推位）：当设置为1时，要求把数据尽快的交给应用层，不做处理</p><p>急数据：URG标志设置为1时，紧急指针才有效，紧急方式是向对方发送紧急数据的一种方式，表示数据要优先处理。他是一个正的偏移量，与TCP收不中序号字段的值相加表示紧急数据后面的字节，即紧急指针是指向紧急数据最后一个字节的下一个字节。这是协议编写上的错误，RFC1122中对此给出了更正说明，紧急指针是数据最后一个字节，不是最后字节的下一位置，TCP首部中只有紧急指针指出紧急数据的位置，他所指的字节为紧急数据，但没有办法指定紧急数据的长度。</p><p>　　URG=1，表示紧急指针指向包内数据段的某个字节（数据从第一字节到指针所指向字节就是紧急数据）不进入缓冲区（一般不都是待发送的数据要先进入发送缓存吗？就直接交个上层进程，余下的数据都是要进入接收缓冲的；一般来说TCP是要等到整个缓存都填满了后在向上交付，但是如果PSH=1的话，就不用等到整个缓存都填满，直接交付，但是这里的交付仍然是从缓冲区交付的，URG是不要经过缓冲区的。</p><blockquote><p> 剩下的不去记了没啥意思</p></blockquote><h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><ul><li><p><a href="https://blog.poetries.top/http-protocol/">https://blog.poetries.top/http-protocol/</a></p></li><li><p><a href="https://www.cnblogs.com/qingjiaowoxiaoxioashou/p/6506157.html">https://www.cnblogs.com/qingjiaowoxiaoxioashou/p/6506157.html</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;同上，是之前没回答上来的问题。&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="HTTP" scheme="http://example.com/tags/HTTP/"/>
    
    <category term="TCP" scheme="http://example.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>TCP 四次挥手整理</title>
    <link href="http://example.com/2020/12/22/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%95%B4%E7%90%86/"/>
    <id>http://example.com/2020/12/22/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%95%B4%E7%90%86/</id>
    <published>2020-12-22T07:55:37.000Z</published>
    <updated>2023-05-14T13:50:41.560Z</updated>
    
    <content type="html"><![CDATA[<p>昨天面试计算机网络相关的问题都没答上。甚是羞愧。故而整理一下文章。</p><a id="more"></a> <p><img src="https://img-blog.csdnimg.cn/20201222164929647.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzdG9uZTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>被问到的问题就是TCP四次挥手的状态。想了半天，的确没有这个印象。</p><p>只记下来他的过程而已。</p><hr><p>捋一下它的状态变化。</p><p>首先主动和被动关闭方之前都是ESTABLISHED状态。</p><p>ESTABLISHED的意思是<strong>建立连接。表示两台机器正在通信</strong>。</p><p>然后主动方发送第一个<code>FIN=1，seq=u</code>自己进入<strong>FIN-WAIT-1</strong>，被动方收到后进入<strong>CLOSE-WAIT</strong>阶段。</p><p>在被动关闭连接情况下，在已经接收到FIN，但是还没有发送自己的FIN的时刻，连接处于CLOSE_WAIT状态。</p><p>FIN-WAIT-1就是等待对面回复ACK时候的状态。</p><p>(这两个状态有点通过过程推状态的意思了，那么我只要记住这个过程就行了，然后再把名字记下。也就是状态名没有什么特殊的意义…)</p><p>FIN-WAIT-2 就是收到对方ACK后进入状态。</p><p>然后把被动方数据发完~</p><p>被动方发出FIN报文，进入LAST_ACK状态。等待最后一个ACK?</p><p>然后主动方收到FIN报文后，进入TIME_WAIT状态。返回ACK报文。</p><p>被动方收到后关闭连接。</p><p>主动方等待2MSL 后关闭连接。</p><p>这用嘴说容易糊。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">A(主动关闭)      B(被动关闭)</span><br><span class="line">established   established</span><br><span class="line">fin-wait-1-&gt;FIN&#x3D;1   |</span><br><span class="line"> |                      |</span><br><span class="line"> |  &lt;-ACK&#x3D;1close_wait</span><br><span class="line"> | |</span><br><span class="line"> fin-wait-2             |</span><br><span class="line"> |       数据传送        |</span><br><span class="line"> |&lt;-ACK&#x3D;1 FIN&#x3D;1  LASK_ACK</span><br><span class="line"> ||</span><br><span class="line"> TIME_WAIT -&gt;ACK&#x3D;1      |</span><br><span class="line"> |                      |</span><br><span class="line"> | CLOSED</span><br><span class="line"> | 2msl|</span><br><span class="line"> CLOSED</span><br></pre></td></tr></table></figure><p>昨天要是能把这个图给他一画不是起飞？</p><p>顺势整理下握手阶段的吧。    </p><hr><p><img src="https://img-blog.csdnimg.cn/20201222164929645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzdG9uZTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A(主动打开方)       B(被动打开方)</span><br><span class="line">CLOSED                CLOSED</span><br><span class="line"> |  |</span><br><span class="line">  |LISTEN</span><br><span class="line">SYN-SENT  SYN=<span class="number">1</span>-&gt;        |</span><br><span class="line">  | |</span><br><span class="line">  |   &lt;- SYN=<span class="number">1</span> ACK=<span class="number">1</span>    SYN-RECD</span><br><span class="line">  | |</span><br><span class="line">  ESTABLISHED ACK=<span class="number">1</span>-&gt;    |</span><br><span class="line">  |ESTABLISED</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>为什么有这么一个listen状态…</p><ul><li>LISTEN：侦听来自客户端的TCP端口的<strong>连接请求</strong></li></ul><p>BTW：</p><p>顺带推荐下:</p><p><a href="https://draveness.me/whys-the-design-tcp-three-way-handshake/">为什么 TCP 建立连接需要三次握手</a></p><p><a href="https://draveness.me/whys-the-design-tcp-time-wait/">为什么 TCP 协议有 TIME_WAIT 状态</a></p><hr><p>参考：</p><p><a href="https://www.jianshu.com/p/9968b16b607e">https://www.jianshu.com/p/9968b16b607e</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;昨天面试计算机网络相关的问题都没答上。甚是羞愧。故而整理一下文章。&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode-LRU 探究</title>
    <link href="http://example.com/2020/12/20/LEETCODE-LRU%E6%8E%A2%E7%A9%B6/"/>
    <id>http://example.com/2020/12/20/LEETCODE-LRU%E6%8E%A2%E7%A9%B6/</id>
    <published>2020-12-20T11:49:07.000Z</published>
    <updated>2023-05-14T13:50:41.558Z</updated>
    
    <content type="html"><![CDATA[<p>Leetcode上看到这题，感觉是个很有意思的题目，好好整一整</p><a id="more"></a> <p><em>LRU</em>(Least recently used,最近最少使用)</p><p>一个经典的使用场景：<strong>CPU的高速缓存</strong></p><hr><h3 id="1-基于哈希表和双向链表实现LRU"><a href="#1-基于哈希表和双向链表实现LRU" class="headerlink" title="1.基于哈希表和双向链表实现LRU"></a>1.基于哈希表和双向链表实现LRU</h3><p>整体的设计思路是，可以使用 HashMap 存储 key，这样可以做到 save 和 get key的时间都是 O(1)，而 HashMap 的 Value 指向双向链表实现的 LRU 的 Node 节点。</p><blockquote><p>有点不太能理解,</p></blockquote><p>貌似我想的并不是很清楚 头有点大</p><p>双向链表的好处在哪呢</p><p>冷静一下</p><p>先上我这个很挫的代码 。复杂度应该都是O(n)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我这个思路 数据反而实际存在hash表里</span></span><br><span class="line"><span class="comment"># 然后维护一个last_used列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把用到的放在队首</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.max_capacity=capacity</span><br><span class="line">        self.dict_struct=<span class="built_in">dict</span>()</span><br><span class="line">        self.last_used=<span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># 如果已经在LRU中</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.dict_struct:</span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">in</span> self.last_used:</span><br><span class="line">                <span class="keyword">if</span> self.last_used[-<span class="number">1</span>]==key:</span><br><span class="line">                    <span class="keyword">return</span> self.dict_struct[key]</span><br><span class="line">                </span><br><span class="line">                to_pop=-<span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> index,value <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.last_used):</span><br><span class="line">                    <span class="keyword">if</span> value==key:</span><br><span class="line">                        to_pop=index</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">#删一个插一个很合理啊</span></span><br><span class="line">                self.last_used.pop(to_pop)</span><br><span class="line">                self.last_used.append(key)</span><br><span class="line">            <span class="comment">#不在缓存队列中</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(self.last_used)==self.max_capacity:</span><br><span class="line">                    self.last_used.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">                self.last_used.append(key)</span><br><span class="line">            <span class="keyword">return</span> self.dict_struct[key]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="comment"># 有足够的空间加入</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.dict_struct:</span><br><span class="line">            self.dict_struct[key]=value</span><br><span class="line">            to_pop=-<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> index,value <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.last_used):</span><br><span class="line">                <span class="keyword">if</span> value==key:</span><br><span class="line">                    to_pop=index</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">            self.last_used.pop(to_pop)</span><br><span class="line">            self.last_used.append(key)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.last_used)+<span class="number">1</span>&lt;=self.max_capacity:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">del</span> self.dict_struct[self.last_used[<span class="number">0</span>]]</span><br><span class="line">            self.last_used.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        self.dict_struct[key]=value        </span><br><span class="line">        self.last_used.append(key)</span><br></pre></td></tr></table></figure><hr><p>麻烦点就在于:</p><ul><li>随机访问</li><li>需要将数据插到头部尾部</li></ul><p>犯困 搞不明白啊。</p><p>二战LRU</p><p>先把设计思路搞清晰，一切就都明朗了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">读</span><br><span class="line">​-------数据不存在: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">​-------数据存在: 将数据移动到头(这边设定越靠近头数据越新) 返回数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 写 数据是否存在-&gt;</span><br><span class="line">              --存在key:定位，修改值，移动到头</span><br><span class="line">                |</span><br><span class="line">                | 不存在key:</span><br><span class="line">|--------容量达到上限:那就把尾巴的删了 同时对应hashtable里的数据也得删再往头那里写。</span><br><span class="line">  |-------容量未达上限:未达上限就只管往头那里写就完了</span><br><span class="line">      </span><br><span class="line"> </span><br><span class="line">  hashtable doubleLinkedlist</span><br><span class="line">  key: 对应值</span><br><span class="line">  </span><br><span class="line">还有一个麻烦点就在于双向链表的实现</span><br><span class="line">注意一下细节.只有当缓存没满时，size在变化</span><br><span class="line">还有就是注意添加的是cache在添加和删除的时候变化</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DLinkListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,key=<span class="number">0</span>,value=<span class="number">0</span></span>):</span></span><br><span class="line">        self.key=key</span><br><span class="line">        self.value=value</span><br><span class="line">        self.prev=<span class="literal">None</span></span><br><span class="line">        self.<span class="built_in">next</span>=<span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.cache=<span class="built_in">dict</span>()</span><br><span class="line">        <span class="comment"># 伪头伪尾</span></span><br><span class="line">        self.tail=DLinkListNode()</span><br><span class="line">        self.head=DLinkListNode()</span><br><span class="line">        self.head.<span class="built_in">next</span>=self.tail</span><br><span class="line">        self.tail.prev=self.head</span><br><span class="line">        self.capacity=capacity</span><br><span class="line">        self.size=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.cache:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        node = self.cache[key]</span><br><span class="line">        self.moveToHead(node)</span><br><span class="line">        <span class="keyword">return</span> node.value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.cache:</span><br><span class="line">            <span class="comment"># 初始化</span></span><br><span class="line">            node = DLinkListNode(key,value)</span><br><span class="line">            self.cache[key]=node</span><br><span class="line">            self.addToHead(node)</span><br><span class="line">            self.size+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.size&gt;self.capacity:</span><br><span class="line">                removed = self.removeTail()</span><br><span class="line">                <span class="comment">#pop</span></span><br><span class="line">                self.cache.pop(removed.key)</span><br><span class="line">                self.size-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node=self.cache[key]</span><br><span class="line">            node.value=value</span><br><span class="line">            self.moveToHead(node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addToHead</span>(<span class="params">self,node</span>):</span></span><br><span class="line">        <span class="comment"># o-&gt;o o-&gt;N-&gt;o</span></span><br><span class="line">        head_next = self.head.<span class="built_in">next</span></span><br><span class="line">        node.prev=self.head</span><br><span class="line">        node.<span class="built_in">next</span>=head_next</span><br><span class="line">        head_next.prev=node</span><br><span class="line">        self.head.<span class="built_in">next</span>=node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNode</span>(<span class="params">self,node</span>):</span></span><br><span class="line">        node.prev.<span class="built_in">next</span>=node.<span class="built_in">next</span></span><br><span class="line">        node.<span class="built_in">next</span>.prev=node.prev</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveToHead</span>(<span class="params">self,node</span>):</span></span><br><span class="line">        self.removeNode(node)</span><br><span class="line">        self.addToHead(node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeTail</span>(<span class="params">self</span>):</span></span><br><span class="line">        node = self.tail.prev</span><br><span class="line">        self.removeNode(node)</span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure><p>操作还是封装在LRU里的</p><p>LRU果然没有经过测试的东西就是不可靠的。</p><p>有机会应该走一走单元测试，找点感觉。</p><hr><h3 id="Redis的LRU实现"><a href="#Redis的LRU实现" class="headerlink" title="Redis的LRU实现"></a>Redis的LRU实现</h3><hr><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/34133067">https://zhuanlan.zhihu.com/p/34133067</a><ul><li><a href="https://leetcode-cn.com/problems/lru-cache/solution/lruhuan-cun-ji-zhi-by-leetcode-solution/">https://leetcode-cn.com/problems/lru-cache/solution/lruhuan-cun-ji-zhi-by-leetcode-solution/</a>    </li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Leetcode上看到这题，感觉是个很有意思的题目，好好整一整&lt;/p&gt;</summary>
    
    
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Redis 设计与实现读书笔记(三).md</title>
    <link href="http://example.com/2020/12/20/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B03-md/"/>
    <id>http://example.com/2020/12/20/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B03-md/</id>
    <published>2020-12-20T07:29:13.000Z</published>
    <updated>2023-05-14T13:50:41.561Z</updated>
    
    <content type="html"><![CDATA[<p>终于来到我最喜欢的复制哨兵集群部分</p><a id="more"></a> <hr><h4 id="复制-换句话说就是主从服务器"><a href="#复制-换句话说就是主从服务器" class="headerlink" title="复制(换句话说就是主从服务器)"></a>复制(换句话说就是主从服务器)</h4><p>用户可以通过SLACEOF命令，让一个服务器去复制另一个服务器，我们称呼被复制的服务器为<strong>主服务器</strong>(master)，而对主服务器进行复制的服务器被称为从服务器(slave).</p><hr><h5 id="旧版复制功能的实现"><a href="#旧版复制功能的实现" class="headerlink" title="旧版复制功能的实现"></a>旧版复制功能的实现</h5><p>Redis的复制功能分为<strong>同步</strong>(sync)和<strong>命令传播</strong>(command propagate)两个操作:</p><ul><li>同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态。</li><li>命令传播操作则用于在<strong>主服务器的数据库状态被修改</strong>，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态。</li></ul><hr><h6 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h6><p>从服务器对主服务器的同步操作需要通过向主服务器发起SYNC命令来完成，以下是SYNC命令的执行步骤:</p><p>1)从服务器向主服务器发送SYNC命令。</p><p>2)收到SYNC命令的主服务器执行BGSAVE，在后台生成一个RDB文件，并使用一个缓冲区记录从现在执行的所有写命令。</p><p>3)当主服务器的BGSAVE命令执行完毕，主服务器会将BGSAVE命令生成的RDB文件发送给从服务器，从服务器接收并载入这个RDB文件，将自己的数据库状态更新至主服务器执行BGSAVE命令时的数据库状态。</p><p>4）住服务将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些写命令，将自己的数据库状态更新至主服务器数据当前所处的状态。</p><blockquote><p>按我自己来看，就是生成一份快照，然后再把生成快照期间产生的发过来。乍一看还是非常合理的呀。</p></blockquote><h6 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h6><p>在同步操作执行完毕之后，主从服务两者的数据库将达到一致状态，但这种一致并不是一成不变的，每当主服务器执行<strong>客户端</strong>发送的写命令时，主服务器的数据库就有可能会被修改，并导致主从服务器状态不再一致。</p><blockquote><p>就是同步完后又修改了，然后必然不一致。</p></blockquote><p>为了让主从服务器再次回到一致状态，主服务器需要对从服务执行命令传播操作:主服务器会将自己执行的写命令，也即是造成主从服务器不一致的那条写命令，发送给从服务器执行，当从服务器执行了同样的写命令之后，主从服务器再次回到一致状态。</p><p>缺陷:</p><p>从服务器对主服务器的复制分为:</p><p>1.初次复制.</p><p>2.断线后重复制.</p><p>对于初次复制，旧版复制功能能很好地完成任务，但断线后重复制，能完成任务，但是效率低。</p><blockquote><p>就是他的断线重复制没有任何的记忆。只能全部重头来一遍。</p></blockquote><hr><h5 id="新版复制功能的实现"><a href="#新版复制功能的实现" class="headerlink" title="新版复制功能的实现"></a>新版复制功能的实现</h5><p>Redis从2.8版本开始，使用PSYNC命令代替SYNC命令来执行复制时的同步操作。</p><p>PSYNC具有完整重同步和部分重同步两种模式</p><ul><li>完整重同步用于初次复制,和SYNC是一样的。</li><li>部分重<strong>复制</strong>用于断线后重<strong>复制</strong>，当从服务器重连后，如果条件允许，主服务器将主从服务器断线期间写命令发给从服务器。</li></ul><blockquote><p>举个不太恰当的例子，相当于加了一个断点续存的功能。</p></blockquote><p>部分重同步功能由以下三个部分构成:</p><ul><li>主服务器的复制偏移量和从服务的复制偏移量。</li><li>主服务的复制积压区。</li><li>服务器的运行ID。</li></ul><p>1.主服务器每次向服务传播N个字节数据，将自己的复制偏移量加上N。</p><p>2.从服务器每次收到主服务传播来的n个字节的数据，将自己的复制偏移量加上N。</p><blockquote><p>有点那种TCP的序号的意思？</p></blockquote><p>复制积压缓冲区由主服务器维护的一个固定长度先进先出队列。</p><p>当主服务器进行命令传播时，不仅会将写命令发送到所有从服务器，还会写到复制积压缓冲区。</p><p>保存的是偏移量和对应字节。</p><blockquote><p>这个可以，只积压一部分。太多直接完整重同步了。</p></blockquote><p>还有一个运行ID，就是检验是不是对应主服务器罢了。</p><blockquote><p>这个业务逻辑还是非常清晰的。</p></blockquote><hr><h4 id="哨兵-Sentinel"><a href="#哨兵-Sentinel" class="headerlink" title="哨兵(Sentinel)"></a>哨兵(Sentinel)</h4><p>Sentinel是Redis的高可用性(highg availability)(CAP)?解决方案：由一个或多个Sentinel组成的哨兵系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器下线状态时，自动将主武器属下的某个从服务器升级为新的主服务器。</p><p>当主服务的下线时长超过用户设定的下线时长上限时，Sentinel系统就会对主服务器进行<strong>故障转移</strong>操作：</p><ul><li>挑选一个从服务器，升级为新的主服务器。</li><li>之后sentinel会向之前主服务器下所有服务器发送新的复制指令，让他们成为新的主服务器的从服务器，当所有从服务器都开始复制新的主服务器时，故障转移操作执行完毕。</li><li>sentinel还会继续监视已下线的主服务器，当它重新上线时，让它成为新的主服务器的从服务器。</li></ul><blockquote><p>有点虎符的意思，虎符在谁手上听谁的。</p></blockquote><p>Sentinel本质上只是一个运行在特殊模式下的Redis服务器</p><blockquote><p>突发奇想，sentinel挂了咋办</p></blockquote><hr><h5 id="获取主服务器信息"><a href="#获取主服务器信息" class="headerlink" title="获取主服务器信息"></a>获取主服务器信息</h5><p>sentinel默认会以每10秒一次的频率，通过命令连接向被监视的主服务器发送INFO命令，并通过回复获取主服务器的当前信息。</p><hr><p>从服务器同样也是10一次发送INFO命令</p><hr><h5 id="检测主观下线状态"><a href="#检测主观下线状态" class="headerlink" title="检测主观下线状态"></a>检测主观下线状态</h5><p>默认情况下，sentinel会以每秒1次的频率想所有与它创建了命令连接的实例发送PING命令，并通过实例返回的PING命令回复来判断实例是否在线。</p><p>根据配置文件down_after-milliseconds 设为50000ms，如果主服务器连续50000mss都返回无效回复。</p><p>sentinel就会标记会主观下线。</p><blockquote><p>就是不是一次就定生死，还是会给一点机会的。</p></blockquote><h5 id="检测客观下线状态"><a href="#检测客观下线状态" class="headerlink" title="检测客观下线状态"></a>检测客观下线状态</h5><p>当sentinel将一个主服务器判断为主观下线，为了确认这个服务器是否真的下线，它会向同样监视这一主服务器的其他sentinel进行询问，当下线判断数量足够时，sentinel就会将服务器判定为客观下线，并对主服务器进行故障转移。</p><h5 id="选举领头Sentinel"><a href="#选举领头Sentinel" class="headerlink" title="选举领头Sentinel:"></a>选举领头Sentinel:</h5><p>由领头sentinel对下线主服务进行故障转移操作</p><p>选举办法。</p><ul><li>所有在线的sentinel都有选为领头Sentinel的资格</li><li>每次进行领头选举之后，sentinel的配置纪元的值都会自增一次。一个计数器。</li></ul><blockquote><p>配置纪元相当于选举届数</p></blockquote><ul><li>在一个配置纪元里面，所有sentinel都有一个一个sentinel设为局部sentinel的机会。这次不可修改。</li></ul><blockquote><p>每个人都有选票</p></blockquote><ul><li>拉票命令sentinel-is-maser-down-by-addr 拉票命令</li><li>规矩是先到先得;后面的都会被拒绝。</li><li>如果有某人sentinel被半数以上选举，那就成为领头sentinel.（10个需要6个)</li><li>规定时间内，没选举处理。再在一段时间后再进行选举，直到选出来为止。</li></ul><hr><p>选择新主服务器：</p><ul><li><p>删除下线或者断线的肯定要走</p></li><li><p>删除最近五秒没回复领头Sential INFO</p></li><li><p>删除与已下线主服务器连接断开超过，down_affter_milliseconds * 10 为了数据比较新</p></li><li><p>然后看优先级，优先级看完看偏移量，如果还不行看ID。</p></li></ul><hr><h4 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h4><p>Redis集群是Redis提供的分布式数据库方案，集群通过分片来进行数据共享，并提供复制和故障转移功能。介绍集群的节点、槽指派、命令执行、重新分片、转向、故障转移、消息。</p><h5 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h5><p>Redis集群由多个节点组成。它们都处于一个只包含自己的集群当中，要组建集群，就要把独立的节点连接起来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster meet</span><br></pre></td></tr></table></figure><hr><p>槽指派</p><p>Redis集群通过分片的方式保存数据库中的键值对:集群的整个数据库被分为16384个槽(slot),集群中的每个节点可以处理0个或16384个槽。</p><p>​    当数据库的16384个槽都有节点在处理时，集群处于上线状态。任意一个槽没有得到处理，集群处于下线状态。</p><blockquote><p>有一致性哈希那味了</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster addslots 指派槽给节点</span><br></pre></td></tr></table></figure><hr><h5 id="在集群中执行命令"><a href="#在集群中执行命令" class="headerlink" title="在集群中执行命令"></a>在集群中执行命令</h5><p>当客户端向节点发送与数据库键有关的命令时，接收命令的节点会计算出命令要处理的数据库键属于哪个槽，并检查这个槽是否指派给了自己:</p><ul><li>如果键锁在的槽正好就指派给了当前节点，那么节点直接执行这个命令。</li><li>如果没有指派给当前节点，节点向客户端返回一个moved错误，直营客户端redirect至正确的节点，并再次发送之前想要执行的命令。</li></ul><p>计算key属于哪个槽算法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">slot_number</span>(<span class="params">key</span>):</span></span><br><span class="line">  <span class="keyword">return</span> crc16(key) &amp; <span class="number">16383</span></span><br></pre></td></tr></table></figure><hr><h5 id="重新分片"><a href="#重新分片" class="headerlink" title="重新分片"></a>重新分片</h5><p>将任意数量已经指派给某个节点的槽改为指派给另一个节点，相关的键值对也会转移。</p><p>不需要下线，源节点和目标节点都可以继续处理命令请求。</p><hr><h5 id="ASK错误"><a href="#ASK错误" class="headerlink" title="ASK错误:"></a>ASK错误:</h5><p>命令要处理的数据库键恰好属于正在被迁移的槽:</p><ul><li>先在自己数据库找，找到直接返回。</li><li>没找到，返回一个ask错误，指引客户端转向目标节点。</li></ul><hr><h5 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h5><p>集群中的每个节点都会定期地向集群中的其他节点发送ping消息，以检测对方是否在线，如果在规定时间内没有返回pong，那么标记为疑似下线。</p><blockquote><p>这和之前哨兵不一样，他们是自己检举自己，哨兵是别人监管他们。那这么看好像哨兵效率更高一些。</p></blockquote><p>如果在一个集群中，半数以上负责处理槽的主节点都把某个主节点x报告为疑似下线，那么这个主节点x被标记为已下线，将主节点x标记为已下线的节点会向集群广播一条关于主节点x的fail信息。所有收到这条fail消息的节点，都会标记x已下线。</p><hr><p>选举新节点和哨兵选择新领头是一样的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;终于来到我最喜欢的复制哨兵集群部分&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="redis" scheme="http://example.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Raft 论文阅读笔记</title>
    <link href="http://example.com/2020/12/17/raft%E8%AE%BA%E6%96%87%E2%80%94-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2020/12/17/raft%E8%AE%BA%E6%96%87%E2%80%94-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</id>
    <published>2020-12-17T15:32:06.000Z</published>
    <updated>2023-05-14T13:50:41.561Z</updated>
    
    <content type="html"><![CDATA[<p>Raft 将一致性问题分解成了三个相对独立的子问题，这些问题会在接下来的子章节中进行讨论：</p><a id="more"></a> <ul><li><strong>领导选举</strong>：当现存的领导人宕机的时候, 一个新的领导人需要被选举出来（章节 5.2）</li><li><strong>日志复制</strong>：领导人必须从客户端接收日志条目(log entries)然后复制到集群中的其他节点，并且强制要求其他节点的日志保持和自己相同。</li><li><strong>安全性</strong>：在 Raft 中安全性的关键是在图 3 中展示的状态机安全：如果有任何的服务器节点已经应用了一个确定的日志条目到它的状态机中，那么其他服务器节点不能在同一个日志索引位置应用一个不同的指令。章节 5.4 阐述了 Raft 算法是如何保证这个特性的；这个解决方案涉及到一个额外的选举机制（5.2 节）上的限制。</li></ul><hr><table><thead><tr><th>特性</th><th>解释</th></tr></thead><tbody><tr><td>选举安全特性</td><td>对于一个给定的任期号，最多只会有一个领导人被选举出来（5.2 节）</td></tr><tr><td>领导人只附加原则</td><td>领导人绝对不会删除或者覆盖自己的日志，只会增加（5.3 节）</td></tr><tr><td>日志匹配原则</td><td>如果两个日志在相同的索引位置的日志条目的任期号相同，那么我们就认为这个日志从头到这个索引位置之间全部完全相同（5.3 节）</td></tr><tr><td>领导人完全特性</td><td>如果某个日志条目在某个任期号中已经被提交，那么这个条目必然出现在更大任期号的所有领导人中（5.4 节）</td></tr><tr><td>状态机安全特性</td><td>如果一个领导人已经将给定的索引值位置的日志条目应用到状态机中，那么其他任何的服务器在这个索引位置不会应用一个不同的日志（5.4.3 节）</td></tr></tbody></table><h4 id="5-1RAFT基础"><a href="#5-1RAFT基础" class="headerlink" title="5.1RAFT基础"></a>5.1RAFT基础</h4><p>一个 Raft 集群包含若干个服务器节点；5 个服务器节点是一个典型的例子，这允许整个系统容忍 2 个节点失效。在任何时刻，每一个服务器节点都处于这三个状态之一：<strong>领导人、跟随者或者候选人</strong>。在通常情况下，系统中只有一个领导人并且其他的节点全部都是跟随者。跟随者都是被动的：<strong>他们不会发送任何请求</strong>，只是简单的响应来自领导者或者候选人的请求。领导人处理所有的客户端请求（如果一个客户端和跟随者联系，那么跟随者会把请求重定向给领导人）。第三种状态，候选人，是用来在 5.2 节描述的选举新领导人时使用。图 4 展示了这些状态和他们之间的转换关系；这些转换关系会在接下来进行讨论。    </p><p>Raft 把时间分割成任意长度的<strong>任期</strong>，如图 5。任期用连续的整数标记。每一段任期从一次<strong>选举</strong>开始，就像章节 5.2 描述的一样，一个或者多个候选人尝试成为领导者。如果一个候选人赢得选举，然后他就在接下来的任期内充当领导人的职责。在某些情况下，一次选举过程会造成选票的瓜分。在这种情况下，这一任期会以没有领导人结束；一个新的任期（和一次新的选举）会很快重新开始。Raft 保证了在一个给定的任期内，最多只有一个领导者。</p><p>不同的服务器节点可能多次观察到任期之间的转换，但在某些情况下，一个节点也可能观察不到任何一次选举或者整个任期全程。任期在 Raft 算法中充当逻辑时钟的作用，这会允许服务器节点查明一些过期的信息比如陈旧的领导者。每一个节点存储一个当前任期号，这一编号在整个时期内单调的增长。当服务器之间通信的时候会交换当前任期号；如果一个服务器的当前任期号比其他人小，那么他会更新自己的编号到较大的编号值。如果一个候选人或者领导者发现自己的任期号过期了，那么他会立即恢复成跟随者状态。如果一个节点接收到一个包含过期的任期号的请求，那么他会直接拒绝这个请求。</p><p>Raft 算法中服务器节点之间通信使用远程过程调用（RPCs），并且基本的一致性算法只需要两种类型的 RPCs。请求投票（RequestVote） RPCs 由候选人在选举期间发起（章节 5.2），然后附加条目（AppendEntries）RPCs 由领导人发起，用来复制日志和提供一种心跳机制（章节 5.3）。第 7 节为了在服务器之间传输快照增加了第三种 RPC。当服务器没有及时的收到 RPC 的响应时，会进行重试， 并且他们能够并行的发起 RPCs 来获得最佳的性能。</p><hr><h4 id="5-2领导人选举"><a href="#5-2领导人选举" class="headerlink" title="5-2领导人选举"></a>5-2领导人选举</h4><p>Raft 使用一种心跳机制来触发领导人选举。当服务器程序启动时，他们都是跟随者身份。一个服务器节点继续保持着跟随者状态只要他从领导人或者候选者处接收到有效的 RPCs。领导者周期性的向所有跟随者发送心跳包（即不包含日志项内容的附加日志项 RPCs）来维持自己的权威。如果一个跟随者在一段时间里没有接收到任何消息，也就是<strong>选举超时</strong>，那么他就会认为系统中没有可用的领导者,并且发起选举以选出新的领导者。</p><p>要开始一次选举过程，跟随者先要增加自己的当前任期号并且转换到候选人状态。然后他会并行的向集群中的其他服务器节点发送请求投票的 RPCs 来给自己投票。候选人会继续保持着当前状态直到以下三件事情之一发生：**(a) 他自己赢得了这次的选举，(b) 其他的服务器成为领导者，(c) 一段时间之后没有任何一个获胜的人。**这些结果会分别的在下面的段落里进行讨论。</p><p>当一个候选人从整个集群的大多数服务器节点获得了针对同一个任期号的选票，那么他就赢得了这次选举并成为领导人。每一个服务器最多会对一个任期号投出一张选票，按照先来先服务的原则（注意：5.4 节在投票上增加了一点额外的限制）。要求大多数选票的规则确保了最多只会有一个候选人赢得此次选举（图 3 中的选举安全性）。一旦候选人赢得选举，他就立即成为领导人。<strong>然后他会向其他的服务器发送心跳消息来建立自己的权威并且阻止新的领导人的产生。</strong></p><p>在等待投票的时候，候选人可能会从其他的服务器接收到声明它是领导人的附加日志项 RPC。如果这个领导人的任期号（包含在此次的 RPC中）不小于候选人当前的任期号，那么候选人会承认领导人合法并回到跟随者状态。 <strong>如果此次 RPC 中的任期号比自己小，那么候选人就会拒绝这次的 RPC 并且继续保持候选人状态</strong>。</p><p>第三种可能的结果是候选人既没有赢得选举也没有输：如果有多个跟随者同时成为候选人，那么选票可能会被瓜分以至于没有候选人可以赢得大多数人的支持。当这种情况发生的时候，<strong>每一个候选人都会超时，然后通过增加当前任期号来开始一轮新的选举。然而，没有其他机制的话，选票可能会被无限的重复瓜分。</strong></p><p>Raft 算法使用<strong>随机选举超时时</strong>间的方法来确保很少会发生选票瓜分的情况，就算发生也能很快的解决。<strong>为了阻止选票起初就被瓜分，选举超时时间是从一个固定的区间（例如 150-300 毫秒）随机选择。这样可以把服务器都分散开以至于在大多数情况下只有一个服务器会选举超时；然后他赢得选举并在其他服务器超时之前发送心跳包。同样的机制被用在选票瓜分的情况下。每一个候选人在开始一次选举的时候会重置一个随机的选举超时时间，然后在超时时间内等待投票的结果；</strong>这样减少了在新的选举中另外的选票瓜分的可能性。9.3 节展示了这种方案能够快速的选出一个领导人。</p><p>(随机选举超时时间是个啥…)</p><p>领导人选举这个例子，体现了可理解性原则是如何指导我们进行方案设计的。起初我们计划使用一种排名系统：每一个候选人都被赋予一个唯一的排名，供候选人之间竞争时进行选择。如果一个候选人发现另一个候选人拥有更高的排名，那么他就会回到跟随者状态，这样高排名的候选人能够更加容易的赢得下一次选举。但是我们发现这种方法在可用性方面会有一点问题（如果高排名的服务器宕机了，那么低排名的服务器可能会超时并再次进入候选人状态。而且如果这个行为发生得足够快，则可能会导致整个选举过程都被重置掉）。我们针对算法进行了多次调整，但是每次调整之后都会有新的问题。最终我们认为随机重试的方法是更加明显和易于理解的。</p><hr><p>来源:</p><p><a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md#3-paxos-%E7%AE%97%E6%B3%95%E7%9A%84%E9%97%AE%E9%A2%98">https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md#3-paxos-%E7%AE%97%E6%B3%95%E7%9A%84%E9%97%AE%E9%A2%98</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Raft 将一致性问题分解成了三个相对独立的子问题，这些问题会在接下来的子章节中进行讨论：&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode-反转链表相关</title>
    <link href="http://example.com/2020/12/17/LEETCODE-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3/"/>
    <id>http://example.com/2020/12/17/LEETCODE-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3/</id>
    <published>2020-12-17T12:36:42.000Z</published>
    <updated>2023-05-14T13:50:41.558Z</updated>
    
    <content type="html"><![CDATA[<p>反转链表的题还挺多的。也算是做出点感觉来了。</p><a id="more"></a> <h5 id="LEETCODE206-反转链表"><a href="#LEETCODE206-反转链表" class="headerlink" title="LEETCODE206.反转链表"></a>LEETCODE206.反转链表</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> head:<span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        prev= <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">          </span><br><span class="line">          <span class="comment">#交代后事</span></span><br><span class="line">          next_p = head.<span class="built_in">next</span></span><br><span class="line">          head.<span class="built_in">next</span>=prev</span><br><span class="line">          prev=head</span><br><span class="line">          head=next_p</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure><h5 id="LEETCODE92-反转链表II"><a href="#LEETCODE92-反转链表II" class="headerlink" title="LEETCODE92 反转链表II"></a>LEETCODE92 反转链表II</h5><blockquote><p> 反转从位置 <em>m</em> 到 <em>n</em> 的链表。请使用一趟扫描完成反转。</p></blockquote><p>大体思路: 移动m格 找到prev 移动m-n 格找到后续 然后反转</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span>(<span class="params">self, head: ListNode, m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">      <span class="comment"># 主要还是reverse这部分会写迷糊了</span></span><br><span class="line">      <span class="comment"># 思路清晰一下 prev cur 在动</span></span><br><span class="line">      <span class="comment"># head tail 不动</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">tail,head</span>):</span></span><br><span class="line">            prev=tail.<span class="built_in">next</span></span><br><span class="line">            cur=head</span><br><span class="line">            <span class="keyword">while</span> prev!=tail:</span><br><span class="line">                next_p = cur.<span class="built_in">next</span></span><br><span class="line">                cur.<span class="built_in">next</span>=prev</span><br><span class="line">                prev=cur</span><br><span class="line">                cur=next_p          </span><br><span class="line">            <span class="keyword">return</span> head,tail</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 惯例传统艺能 dummy</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        dummy.<span class="built_in">next</span> =head</span><br><span class="line">        </span><br><span class="line">        prev=dummy</span><br><span class="line">       <span class="comment"># 先不考虑 模拟一下假设m=2 那么prev走到1 cur_head走到2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m-<span class="number">1</span>):</span><br><span class="line">            prev=prev.<span class="built_in">next</span></span><br><span class="line">       </span><br><span class="line">        cur_head =prev.<span class="built_in">next</span></span><br><span class="line">        tail=cur_head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-m):</span><br><span class="line">           tail=tail.<span class="built_in">next</span></span><br><span class="line">        next_p = tail.<span class="built_in">next</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment"># 现在前面节点和后面节点都交代完了，可以反转</span></span><br><span class="line">        tail,cur_head=reverse(tail,cur_head)</span><br><span class="line">      <span class="comment"># 现在tail就是实际的tail</span></span><br><span class="line">        tail.<span class="built_in">next</span>=next_p</span><br><span class="line">        prev.<span class="built_in">next</span>=cur_head</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><h5 id="LEETCODE25-K个一组翻转链表"><a href="#LEETCODE25-K个一组翻转链表" class="headerlink" title="LEETCODE25 K个一组翻转链表"></a>LEETCODE25 K个一组翻转链表</h5><blockquote><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p><p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p></blockquote><p>大体思路:和上面一题还是蛮像的。就是不用提前走m，直接走k</p><blockquote><p>总是能踩到莫名的坑 昨天是参数位置错了。今天是被prev和pre坑了</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">self,head,tail</span>):</span></span><br><span class="line">        prev=tail.<span class="built_in">next</span></span><br><span class="line">        cur=head</span><br><span class="line">        <span class="keyword">while</span> prev!=tail:</span><br><span class="line">            next_p=cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span>=prev</span><br><span class="line">            prev=cur</span><br><span class="line">            cur=next_p</span><br><span class="line">        <span class="keyword">return</span> tail,head</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span>(<span class="params">self, head: ListNode, k: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">    <span class="comment"># 惯例传统艺能 dummy</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        dummy.<span class="built_in">next</span> =head</span><br><span class="line">        </span><br><span class="line">        prev=dummy</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            tail =prev</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">                tail=tail.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> tail:<span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment"># 保留后一节点指针</span></span><br><span class="line">            nex = tail.<span class="built_in">next</span></span><br><span class="line">            head,tail=self.reverse(head,tail)</span><br><span class="line"></span><br><span class="line">          <span class="comment">#续上</span></span><br><span class="line">            prev.<span class="built_in">next</span>=head</span><br><span class="line">            tail.<span class="built_in">next</span>=nex</span><br><span class="line">          </span><br><span class="line">          <span class="comment"># 迭代</span></span><br><span class="line">            prev=tail</span><br><span class="line">            head=tail.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><h5 id="LEETCODE24-两两交换列表中的节点"><a href="#LEETCODE24-两两交换列表中的节点" class="headerlink" title="LEETCODE24.两两交换列表中的节点"></a>LEETCODE24.两两交换列表中的节点</h5><p>那这不就是K=2吗</p><blockquote><p>太麻烦了 不如正常解~</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">return</span> self.reverseKGroup(head,<span class="number">2</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">self,head,tail</span>):</span></span><br><span class="line">        prev=tail.<span class="built_in">next</span></span><br><span class="line">        cur=head</span><br><span class="line">        <span class="keyword">while</span> prev!=tail:</span><br><span class="line">            next_p=cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span>=prev</span><br><span class="line">            prev=cur</span><br><span class="line">            cur=next_p</span><br><span class="line">        <span class="keyword">return</span> tail,head</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span>(<span class="params">self, head: ListNode, k: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">    <span class="comment"># 惯例传统艺能 dummy</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        dummy.<span class="built_in">next</span> =head</span><br><span class="line">        </span><br><span class="line">        prev=dummy</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            tail =prev</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">                tail=tail.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> tail:<span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment"># 保留后一节点指针</span></span><br><span class="line">            nex = tail.<span class="built_in">next</span></span><br><span class="line">            head,tail=self.reverse(head,tail)</span><br><span class="line"></span><br><span class="line">          <span class="comment">#续上</span></span><br><span class="line">            prev.<span class="built_in">next</span>=head</span><br><span class="line">            tail.<span class="built_in">next</span>=nex</span><br><span class="line">          </span><br><span class="line">          <span class="comment"># 迭代</span></span><br><span class="line">            prev=tail</span><br><span class="line">            head=tail.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>嘿嘿 再有其他的翻转链表我也不至于不会了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;反转链表的题还挺多的。也算是做出点感觉来了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Redis 设计与实现读书笔记(一)</title>
    <link href="http://example.com/2020/12/16/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B01/"/>
    <id>http://example.com/2020/12/16/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B01/</id>
    <published>2020-12-16T08:58:36.000Z</published>
    <updated>2023-05-14T13:50:41.561Z</updated>
    
    <content type="html"><![CDATA[<p>先将redis设计与实现这一本读完。了解redis的设计思路，再待有时间将Redis源码读一读。看到小一届的学弟早已就Redis源码读完，甚是羞愧。</p><a id="more"></a> <h4 id="数据结构相关"><a href="#数据结构相关" class="headerlink" title="数据结构相关"></a>数据结构相关</h4><h5 id="简单动态字符串-simple-dynamic-string-SDS"><a href="#简单动态字符串-simple-dynamic-string-SDS" class="headerlink" title="简单动态字符串(simple dynamic string, SDS)"></a>简单动态字符串(simple dynamic string, SDS)</h5><p>​    C字符串只会作为字符串字面量用在一些无须对字符串值进行修改的地方，比如打印日志:</p><p>​    当redis需要一个可修改的字符串，都会使用SDS来表示字符串值。</p><p>举个例子,如果客户端执行命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET msg &quot;hello world&quot;</span><br></pre></td></tr></table></figure><p>那么Redis将在数据库中创建一个新的键值对，其中，</p><ul><li>键是一个字符串对象，底层是一个保存着字符串”msg“的SDS.</li><li>值也是个字符串对象，底层使用一个保存”hello world”的SDS.</li></ul><p>再比如,如果客户端执行命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPUSH fruits &quot;apple&quot; &quot;banana&quot; &quot;cherry&quot;</span><br></pre></td></tr></table></figure><ul><li>键是一个字符串对象，底层是一个保存”fruits“的SDS.</li><li>值是一个列表对象，列表对象包含了三个字符串对象。</li></ul><p>除了用来保存数据库中的字符串值之外，SDS还被用作<strong>缓冲区</strong>(buffer),AOF模块中的AOF缓冲区，以及客户端状态的输入缓冲区，都是由SDS实现的。</p><hr><h4 id="SDS的结构"><a href="#SDS的结构" class="headerlink" title="SDS的结构"></a>SDS的结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> len; <span class="comment">//已使用长度</span></span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">free</span>; <span class="comment">//未使用长度</span></span><br><span class="line">  <span class="keyword">char</span> buf[]; <span class="comment">//真实存储</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SDS遵循C字符串以空字符结尾的惯例，”\0“,好处在于SDS可以直接复用一部分C字符串函数库的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;%s&quot;</span>,s-&gt;buf); <span class="comment">//直接打印出来</span></span><br></pre></td></tr></table></figure><h5 id="SDS与C字符串的区别"><a href="#SDS与C字符串的区别" class="headerlink" title="SDS与C字符串的区别"></a>SDS与C字符串的区别</h5><h6 id="1-常数复杂度获取字符串长度"><a href="#1-常数复杂度获取字符串长度" class="headerlink" title="1.常数复杂度获取字符串长度"></a>1.常数复杂度获取字符串长度</h6><p>只需要访问len属性即可，至于创建SDS时len是怎么来的，就要探究具体实现了。</p><h6 id="2-杜绝缓冲区溢出"><a href="#2-杜绝缓冲区溢出" class="headerlink" title="2.杜绝缓冲区溢出"></a>2.杜绝缓冲区溢出</h6><p>举个例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> *dest,<span class="keyword">const</span>,<span class="keyword">char</span> *src)</span></span>;</span><br></pre></td></tr></table></figure><p>因为C字符串不记录自身的长度，所以strcat假定用户在执行这个函数时，已经为dest分配足够的内存，当这假定不成立，就会造成缓冲区溢出。</p><p>SDS的空间分配策略完全杜绝了发送缓冲区溢出的可能性。当SDSAPI需要对SDS进行修改时，API会先检查空间是否足够，如果不够，会进行扩充。</p><p>3.减少修改字符串时带来的内存重分配次数</p><p>两种情况，一种是拼接，也就是扩充，第二种是截断，也就是缩小。</p><p>策略也是两种，空间预分配，惰性空间释放。</p><p>空间预分配的逻辑是这样:</p><p>1.修改后的空间小于1MB,也就是len的值，1：1预分配。用一半剩一半。</p><p>2.如果大于1M,那就固定多给1m.</p><p>惰性空间释放:</p><p>1.当缩短的时候，并不马上内存重分配，而是用free记录起来。</p><p>也有对应的API ，有需要的时候回真正释放SDS未使用空间，所以不用当心内存浪费。</p><h6 id="4-二进制安全"><a href="#4-二进制安全" class="headerlink" title="4.二进制安全."></a>4.二进制安全.</h6><p>主要还是因为’\0’ 导致C语言字符串只能保存文本数据，而不能保存二进制数据。SDS使用len属性的值来判断字符串结束，而不是’\0’.</p><p>5.兼容部分C语言函数</p><p>不赘述</p><hr><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>列表键的底层实现之一就是链表，元素比较多，或者元素都是长字符串时，redis就会用链表作为列表键的底层实现。</p><p>除了链表键之外，发布与订阅、慢查询、监视器等功能也用到了链表，</p><hr><h5 id="链表及链表节点的实现"><a href="#链表及链表节点的实现" class="headerlink" title="链表及链表节点的实现"></a>链表及链表节点的实现</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> * <span class="title">prev</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> * <span class="title">next</span>;</span></span><br><span class="line">  <span class="keyword">void</span> * value;</span><br><span class="line">&#125;listNode;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">  listNode * head;</span><br><span class="line">  listNode * tail;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">// 节点值复制函数</span></span><br><span class="line">  <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">  <span class="comment">// 节点值释放函数</span></span><br><span class="line">  <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr,<span class="keyword">void</span> *key);</span><br><span class="line">&#125;<span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><p>特点:</p><ul><li>双端</li><li>无环</li><li>带头尾指针</li><li>带长度计数器</li><li>多态。 可以用于保存各种不同类型的值</li></ul><hr><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>Redis数据库使用字典作为底层实现</p><p>字典还是哈希键的底层实现之一，元素多或者元素长，则使用字典。</p><h5 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h5><p>redis字典所使用的哈希表由dict.h/dictht结构定义:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">  <span class="comment">// 哈希表数组</span></span><br><span class="line">  dictEntry **table;</span><br><span class="line">  <span class="comment">// 哈希表大小</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">  <span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">  <span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125;dictht;</span><br></pre></td></tr></table></figure><p>table 属性是一个数组，数组中的每一个元素都是一个指向dict.h/dictEntry结构的指针，<strong>每个dictEntry结构保存着一个键值对</strong>。size属性记录了哈希表的大小。</p><h5 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span>&#123;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">void</span> *key;</span><br><span class="line">  <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">    <span class="keyword">void</span> *val;</span><br><span class="line">    <span class="keyword">uint64_t</span> u64;</span><br><span class="line">    <span class="keyword">int64_t</span> s64;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//指向下个哈希表节点，形成链表</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;dictEntry;</span><br></pre></td></tr></table></figure><p>key属性保存着键值对中的键，V属性保存键值对中的值，值可以是一个指针，或者是uint64_t整数，又或者是int64_t 整数。</p><p>​    next属性是指向另个一哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一下，以此解决键冲突。</p><p>Redis中的字典由dict.h/dict结构表示:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span>&#123;</span></span><br><span class="line">  <span class="comment">// 类型特定函数</span></span><br><span class="line">  dictType *type;</span><br><span class="line">  <span class="keyword">void</span> *privdata;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//哈希表</span></span><br><span class="line">  dicthx ht[<span class="number">2</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//rehash索引</span></span><br><span class="line">  <span class="comment">// 当rehash不在进行时，值为-1</span></span><br><span class="line">  <span class="keyword">int</span> rehashidx;</span><br><span class="line">&#125;dict</span><br></pre></td></tr></table></figure><p>一般情况下，只用ht[0]哈希表，ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用。rehashidx记录了rehash目前的进度。</p><h5 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h5><p>随着操作的不断执行，为了让哈希表的负载因子维持在一个合理的范围内，</p><p>程序需要对哈希表的大小进行相应的拓展或者收缩。</p><p>Redis对字典的哈希表进行rehash的步骤如下：</p><p>1)为字典的ht[1]哈希表分配空间</p><ul><li>如果是拓展操作，ht[1]的大小为一个大于等于ht[0].used*2的 2的n次幂(假设used是3,那么大小就应该是8)</li><li>如果是收缩操作，ht[1]的大小为第一个大于等于ht[0].used的2的n次幂(继续假设是3,那么大小就应该是4)</li></ul><p>2)将保存在ht[0]中的所有键值对<strong>rehash</strong>到ht[1]上面；rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上。</p><p>3)当ht[0]包含的所有键值对都迁移到ht[1]之后，(ht[0]变为空表),释放ht[0]，</p><p>将ht[1]设置为ht[0],并在ht[1]新创建一个空表哈希表，为下一次rehash做准备。</p><hr><p>当下面条件任意一个满足时，进行拓展:</p><p>1.没有执行BGSAVE或者BGREWRITEAOF,且负载因子&gt;=1.</p><p>2.在进行，且负载因子&gt;=5</p><p>load_factor = ht[0].used/ht[0].size</p><p>已保存节点数量/哈希表大小</p><p>例如: 大小为4，包含4个键值对的哈希表来说,</p><p>load_factor = 4/4=1 </p><p>当哈希表的负载因子小于0.1时,程序进行收缩。</p><h5 id="4-5-渐进式rehash"><a href="#4-5-渐进式rehash" class="headerlink" title="4.5 渐进式rehash"></a>4.5 渐进式rehash</h5><p>迁移动作是分多次、渐进式地完成的。</p><h6 id="渐进式rehash的步骤："><a href="#渐进式rehash的步骤：" class="headerlink" title="渐进式rehash的步骤："></a>渐进式rehash的步骤：</h6><p>1)为ht[1]分配空间，同时持有两个哈希表。</p><p>2)rehashidx置为0,表示rehash工作开始。</p><p>3)在rehash进行期间，每次对字典增删改查，还会顺带将ht[0]哈希表在<strong>rehashidx索引上的所有键值对</strong>rehash到ht[1].rehash完成后，rehashidx属性值+1.</p><p>4)所有都迁移完后，rehashidx置为1</p><hr><h4 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h4><p>个人觉得是一个很有意思的数据结构</p><p>Redis中的跳跃表由redis.h/zskiplistNode 和redis.h/zskiplist 两个结构定义，其中zskiplistNode 结构用于表示跳跃表节点，而zskiplist结构用户保存跳跃表节点的相关信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zskiplist </span><br><span class="line"> header</span><br><span class="line"> tail</span><br><span class="line"> level 记录目前跳跃表中，层数最大的那个节点的层数。</span><br><span class="line"> length</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zskiplistNode </span><br><span class="line">  level</span><br><span class="line">  backward 指向前一节点</span><br><span class="line">  score 分值</span><br><span class="line">  obj 成员对象</span><br><span class="line">  forward 前进指针</span><br></pre></td></tr></table></figure><p>是zset的实现方式</p><hr><h4 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h4><p>intset是集合键的底层实现之一。当一个集合只包含整数值元素，且元素数量不多，就用整数集合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; SADD numbers 1 3 5 7 9</span><br><span class="line">&gt; OBJECT ENCODING numbers</span><br><span class="line">&quot;INTSET&quot;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&#123;</span></span><br><span class="line">  <span class="comment">// 编码方式</span></span><br><span class="line">  <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 集合包含的元素数量</span></span><br><span class="line">  <span class="keyword">uint32_t</span> length;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 保存元素的数组</span></span><br><span class="line">  <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125;intset;</span><br></pre></td></tr></table></figure><p>整数集合的每个元素都是contents数组的一个数组项，各个项在数组中按值的大小有序地排序。</p><p>虽然intset结构将contents属性声明为int8_t 类型的数组，但实际上contents数组并不包租任何int8_t类型的值，contents数组的真正类型取决于encoding属性的值:</p><ul><li>encoding = INTSET_ENC_INT16，那么contents就是一个int16_t类型的数组，数组里的每个项都是一个int16_t类型的整数值。</li></ul><hr><h5 id="升级"><a href="#升级" class="headerlink" title="升级:"></a>升级:</h5><p>每当一个新元素并现有所有元素的类型都长时，整数集合需要先进行升级，然后才将新元素添加到整数集合里面。</p><p>过程如下：</p><p>1)根据新元素类型，拓展数组的空间大小，并为新元素分配空间。</p><p>2)所有元素都转成新元素的相同类型，且保证有序。</p><p>3)将新元素添加到底层数组里面。</p><h5 id="升级的好处："><a href="#升级的好处：" class="headerlink" title="升级的好处："></a>升级的好处：</h5><p>1.提升灵活性。</p><p>为了避免类型错误，我们通常不会将两种不同类型的值放在同一个数据结构里面。</p><p>2.节约内存。</p><p>有需要的时候才升级。</p><h5 id="6-4降级"><a href="#6-4降级" class="headerlink" title="6.4降级"></a>6.4降级</h5><p>不支持降级 嘿嘿</p><hr><p>压缩列表</p><p>ziplist是列表键和哈希键的底层实现之一。每个列表项要么是小整数值，要么是长度较短的字符串，redis就会用ziplist来做列表键的底层实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; RPUSH lst <span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">10086</span> <span class="string">&quot;hello&quot;</span> <span class="string">&quot;world&quot;</span></span><br><span class="line">&gt; OBJECT ENCODING lst</span><br><span class="line"><span class="string">&quot;ziplist&quot;</span></span><br></pre></td></tr></table></figure><p>另外，当一个哈希键只包含少量键值对，且每个键值对的键和值要么是小整数值，要么是长度较短的字符串，就会使用ziplist作为哈希键的底层实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; HMSET profile “name” “Jack<span class="string">&quot; &quot;</span>age<span class="string">&quot; 28 &quot;</span>job<span class="string">&quot; &quot;</span>Programmer<span class="string">&quot;</span></span><br><span class="line"><span class="string">&gt; OBJECT ENCODING profile</span></span><br><span class="line"><span class="string">  &quot;</span>ziplist<span class="string">&quot;</span></span><br></pre></td></tr></table></figure><h4 id="ziplist构成"><a href="#ziplist构成" class="headerlink" title="ziplist构成"></a>ziplist构成</h4><p>ziplist是Redis为了节约内存而开发的，是由一系列特殊编码的<strong>连续内存块</strong>组成的顺序型数据结构，一个ziplist可以保持任意多个节点(entry),<strong>每一个节点可以保存一个字节数组或者一个整数值</strong>。</p><p><img src="https://img-blog.csdnimg.cn/20201216164130889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzdG9uZTE=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201216164336845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzdG9uZTE=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><hr><h5 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h5><p>Redis并没有直接使用这些数据结构来实现键值数据库，而是基于这些数据结构创建了一个对象系统。</p><p>通过这五种不同类型的对象，Redis可以根据对象的类型来判断一个对象是否可以执行给定的命令。另一个好处是，可以针对不同的场景，为对象设置多种不同的数据结构实现，从而优化对象使用效率。</p><p>Redis采用了引用计数的内存回收机制。还用过引用计数实现了对象共享机制，可以让多个数据库键共享同一个对象来节约内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">  <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125;robj;</span><br></pre></td></tr></table></figure><h5 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h5><p>字符串对象的编码可以是int、raw或者embstr</p><p>列表对象的编码可以是ziplist或者linkedlist</p><p>哈希对象的编码可以是ziplist或者是hashtable</p><p>集合对象的编码可以使intset或者是hashtable</p><p>有序集合对象的编码可以使ziplist或者是skiplist</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;先将redis设计与实现这一本读完。了解redis的设计思路，再待有时间将Redis源码读一读。看到小一届的学弟早已就Redis源码读完，甚是羞愧。&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="redis" scheme="http://example.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>SQL 执行过程 MySQL &amp; TiDB</title>
    <link href="http://example.com/2020/12/08/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8Bmysql-tidb/"/>
    <id>http://example.com/2020/12/08/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8Bmysql-tidb/</id>
    <published>2020-12-08T13:10:22.000Z</published>
    <updated>2023-05-14T13:50:41.562Z</updated>
    
    <content type="html"><![CDATA[<p>答好一道题比泛泛而谈一百道题更重要。</p><a id="more"></a> <p>SQL执行过程</p><p>1.mysql</p><p>我们几乎每天都在写SQL语句，当我们写了一条查询语句，会得到一个查询结果，但是它在MySQL内部是怎样的一个执行过程呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from T where Id = <span class="number">10</span>;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>如图，我们先了解一下MySQL的基本架构示意图。<br><img src="https://img-blog.csdnimg.cn/20200708162607673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1h1bXV5YW5nXw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>整体来看，MySQL分为<code>Server层</code>和<code>存储引擎层</code>两部分。</p><p>​    Server层包括连接器、查询缓存、分析器、优化器、执行器等，包含了大多数核心功能，以及所有内置函数（如日期、时间、数学和加密函数等），所有涉及到跨存储引擎的功能都在这一层实现，如存储过程、触发器、视图等。</p><p>​    存储引擎层负责数据的存储和提取。它的架构模式是插件式的，支持InnoDB、MyISAM、Memory等。我们最多使用的是InnoDB，因为它是MySQL 5.5.5版本后的默认存储引擎。</p><p>从图中可以看出，多种存储引擎公用一个Server层，也就是从连接器到执行器的部分。</p><h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>首先，会连接到数据库上，这时候就是连接器起的作用。连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -h$ip -P$port -u$user -p</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>输完命令之后，需要输入密码。</p><p>连接命令中的mysql是客户端的工具，用来跟服务端建立连接。在完成经典的TCP握手之后，连接器就开始认证身份，也就是我们输入用户名和密码后。如果用户名或密码不对，就会报错<code>“Access denied for user”</code>的错误，这将结束客户端的执行；如果用户名和密码认证通过，连接器会到权限表里面查出你拥有的权限，然后这个链接里面的权限判断逻辑，都将依赖于此时读到的权限。</p><p>这意味着，当一个用户成功建立连接后，及时对这个用户的权限做了修改，也不影响当前连接着的权限，只有再次新建连接时才会使用新的权限设置。</p><p>连接完成后，如果没有其他操作，该连接处于空闲状态，如图：<br><img src="https://img-blog.csdnimg.cn/20200708160936701.png" alt="在这里插入图片描述"><br>如果客户端很长时间没有操作，连接器会自动断开。这个时间可由参数<code>wait_timeout</code>控制，默认是8小时。</p><p>数据库里的 <strong>长连接</strong> 是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。<strong>短连接</strong> 则指的是每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。因为建立连接的过程比较复杂，所以建议尽量使用长连接。</p><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>连接建立完成后，就可以执行select语句了。也就是：查询缓存。</p><p>MySQL拿到一个查询请求后，会先去查询缓存看看之前是不是执行过这个语句。如果执行过，其结果会以key-value对的形式被直接缓存在内存中。如果能够找到缓存中的key，那么这个对应的value就会被直接返回给客户端。</p><p>如果不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。</p><p>虽然使用查询缓存的效率很高，但实质上使用这种方式不太好。因为查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能存了很多结果，还没使用，就被一个更新清空了…</p><h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><p>如果没有命中查询缓存，就该真正执行这个语句去查询了。</p><p>首先，mysql需要知道这条语句是要做什么，因此需要对SQL语句进行解析。首先分析器会做“词法分析”。MySQL需要识别我们输入的多个字符串和空格分别代表什么。MySQL从输入的“select”关键字识别出这是一个查询语句，“T”识别成表名“T”，“ID”识别成“列ID”。然后进行“语法分析”。语法分析器会根据语法规则，判断输入的这个SQL是否满足MySQL语法。<br>如果语句不对，会看到报错<code>You have an error in your SQL syntax</code>提示。</p><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>经过分析器的分析后，MySQL知道要做什么了。开始执行前，还要进行优化器的处理。</p><p>优化器是在表里面有多个索引时，决定使用哪个索引；或者在一个语句有多表关联时，决定各个表的连接顺序。比如有一个两表关联的join：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * <span class="function">from t1 join t2 <span class="title">using</span><span class="params">(ID)</span> where t1.c</span>=<span class="number">10</span> and t2.d=<span class="number">20</span>;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>既可以先从表t1里取出c=10的记录的ID值，再根据ID值关联到表t2，再判断t2里面的d的值是否等于20</li><li>也可以先从表t2里取出d=20的记录的ID值，再根据ID值关联到表t1，再判断t1里面的c的值是否等于10</li></ul><p>这两种执行方法的结果一样，但是执行效率可能不同。优化器的作用就是选择一种效率更高的方式执行。</p><p>优化器阶段完成后，这个语句的执行方案就确定了，然后开始进入执行阶段。</p><h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>开始执行的时候，要先判断一下当前用户有没有查询表T的权限。如果没有，就会返回没有权限的错误：<br><img src="https://img-blog.csdnimg.cn/2020070816172877.png" alt="在这里插入图片描述"><br>如果有权限，就会打开表继续执行。打开表时，执行器会根据表的引擎定义去使用这个引擎提供的接口。</p><p>比如在表T中，ID字段没有索引，那么执行器的执行流程是这样的：</p><ol><li>调用InnoDB引擎接口取该表第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；</li><li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li><li>执行器将上面遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li></ol><p>这条语句到这就执行完成了。</p><p>对于有索引的表，执行逻辑差不多。第一次调用的是“<strong>取满足条件的第一行</strong>”这个接口，之后循环取“<strong>满足条件的下一行</strong>”这个接口，这些接口在引擎中已经定义好了。</p><p>在数据库的慢查询日志中看到的<code>rows_examined</code>字段表示这个语句执行过程中扫描了多少航。这个值就是执行器每次调用执行引擎获取数据行的时候累加的。</p><hr><p>稍微总结一下:</p><p>1.先建立连接2.查询缓存3.分析器 进行语法分析 词法分析，生成抽象语法树 4.优化器 比如走索引5.执行器，权限检验，调用存储引擎，给客户端返回数据</p><hr><p>2.tidb</p><p><img src="https://download.pingcap.com/images/blog-cn/tidb-source-code-reading-3/2.png" alt="SQL 层执行过程"></p><h4 id="引用"><a href="#引用" class="headerlink" title="引用:"></a>引用:</h4><ul><li><a href="https://blog.csdn.net/Xumuyang_/article/details/107207370">https://blog.csdn.net/Xumuyang_/article/details/107207370</a></li><li><a href="https://pingcap.com/blog-cn/tidb-source-code-reading-3/">https://pingcap.com/blog-cn/tidb-source-code-reading-3/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;答好一道题比泛泛而谈一百道题更重要。&lt;/p&gt;</summary>
    
    
    
    
    <category term="sql" scheme="http://example.com/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 如何实现事务</title>
    <link href="http://example.com/2020/12/08/mysql%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BA%8B%E5%8A%A1/"/>
    <id>http://example.com/2020/12/08/mysql%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BA%8B%E5%8A%A1/</id>
    <published>2020-12-08T13:03:59.000Z</published>
    <updated>2023-05-14T13:50:41.560Z</updated>
    
    <content type="html"><![CDATA[<p>mysql如何实现事务</p><a id="more"></a> <h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性:"></a>原子性:</h4><p>想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong>而在 MySQL 中，恢复机制是通过<em>回滚日志</em>（undo log）实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后在对数据库中的对应行进行写入。</p><p>这个过程其实非常好理解，为了能够在发生错误时撤销之前的全部操作，肯定是需要将之前的操作都记录下来的，这样在发生错误时才可以回滚。</p><p>回滚日志除了能够在发生错误或者用户执行 <code>ROLLBACK</code> 时提供回滚相关的信息，它还能够在整个系统发生崩溃、数据库进程直接被杀死后，当用户再次启动数据库进程时，<strong>还能够立刻通过查询回滚日志将之前未完成的事务进行回滚</strong>，这也就需要回滚日志必须先于数据持久化到磁盘上，是我们需要先写日志后写数据库的主要原因。</p><p>回滚日志并不能将数据库物理地恢复到执行语句或者事务之前的样子；它是逻辑日志</p><hr><h4 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h4><p>既然是数据库，那么一定对数据的持久存储有着非常强烈的需求，如果数据被写入到数据库中，那么数据一定能够被安全存储在磁盘上；<strong>而事务的持久性就体现在，一旦事务被提交，那么数据一定会被写入到数据库中并持久存储起来。</strong></p><p>当事务已经被提交之后，就无法再次回滚了，唯一能够撤回已经提交的事务的方式就是创建一个相反的事务对原操作进行『补偿』，这也是事务持久性的体现之一。</p><p>与原子性一样，事务的持久性也是通过日志来实现的，MySQL 使用重做日志（redo log）实现事务的持久性，<strong>重做日志由两部分组成，一是内存中的重做日志缓冲区，因为重做日志缓冲区在内存中，所以它是易失的，另一个就是在磁盘上的重做日志文件，它是持久的。</strong></p><p>当我们在一个事务中尝试对数据进行修改时，<strong>它会先将数据从磁盘读入内存，并更新内存中缓存的数据，然后生成一条重做日志并写入重做日志缓存，当事务真正提交时，MySQL 会将重做日志缓存中的内容刷新到重做日志文件，再将内存中的数据更新到磁盘上</strong>，图中的第 4、5 步就是在事务提交时执行的。</p><hr><h3 id="回滚日志和重做日志"><a href="#回滚日志和重做日志" class="headerlink" title="回滚日志和重做日志"></a>回滚日志和重做日志</h3><p>到现在为止我们了解了 MySQL 中的两种日志，回滚日志（undo log）和重做日志（redo log）；在数据库系统中，事务的原子性和持久性是由事务日志（transaction log）保证的，在实现时也就是上面提到的两种日志，前者用于对事务的影响进行撤销，后者在错误处理时对已经提交的事务进行重做，它们能保证两点：</p><ol><li>发生错误或者需要回滚的事务能够成功回滚（原子性）；</li><li>在事务提交后，数据没来得及写会磁盘就宕机时，在下次重新启动后能够成功恢复数据（持久性）；</li></ol><hr><p>在数据库中，这两种日志经常都是一起工作的，我们<strong>可以</strong>将它们整体看做一条事务日志，其中包含了事务的 ID、修改的行元素以及修改前后的值。</p><hr><h2 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h2><ul><li><code>RAED UNCOMMITED</code>：使用查询语句不会加锁，可能会读到未提交的行（Dirty Read）；</li><li><code>READ COMMITED</code>：只对记录加记录锁，而不会在记录之间加间隙锁，所以允许新的记录插入到被锁定记录的附近，所以再多次使用查询语句时，可能得到不同的结果（Non-Repeatable Read）；<ul><li><code>REPEATABLE READ</code>：多次读取同一范围的数据会返回第一次查询的快照，不会返回不同的数据行，但是可能发生幻读（Phantom Read）；    </li></ul></li><li><code>SERIALIZABLE</code>：InnoDB 隐式地将全部的查询语句加上共享锁，解决了幻读的问题；</li></ul><hr><p>1.使用查询语句不会加锁，读到未提交的数据。</p><p>2.只对<strong>记录加记录锁</strong>，而不会在记录之间间隙锁。所以允许新的记录插入到被锁定记录的附近，所以再多次使用查询语句时，可能得到不同的结果。</p><p>3.多次查询同一范围的数据会返回第一次查询的快照，不会返回不同的数据行，但是可能发生幻读。</p><p>4.Innodb隐式地将全部的查询语句加上共享锁，解决了幻读的问题。</p><p>以上的所有的事务隔离级别都不允许脏写入（Dirty Write），也就是当前事务更新了另一个事务已经更新但是还未提交的数据，大部分的数据库中都使用了 READ COMMITED 作为默认的事务隔离级别，但是 MySQL 使用了 REPEATABLE READ 作为默认配置；从 RAED UNCOMMITED 到 SERIALIZABLE，随着事务隔离级别变得越来越严格，数据库对于并发执行事务的性能也逐渐下降。</p><hr><h3 id="隔离级别的实现"><a href="#隔离级别的实现" class="headerlink" title="隔离级别的实现"></a>隔离级别的实现</h3><p>数据库对于隔离级别的实现就是使用<strong>并发控制机制</strong>对在同一时间执行的事务进行控制，限制不同的事务对于同一资源的访问和更新，而最重要也最常见的并发控制机制，在这里我们将简单介绍三种最重要的并发控制器机制的工作原理。</p><hr><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p>锁是一种最为常见的并发控制机制，在一个事务中，我们并不会将整个数据库都加锁，而是只会锁住那些需要访问的数据项， MySQL 和常见数据库中的锁都分为两种，共享锁（Shared）和互斥锁（Exclusive），前者也叫读锁，后者叫写锁。</p><h4 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h4><p>除了锁，另一种实现事务的隔离性的方式就是通过时间戳，使用这种方式实现事务的数据库，例如 PostgreSQL 会为每一条记录保留两个字段；<em>读时间戳</em>中包括了所有访问该记录的事务中的最大时间戳，而记录行的<em>写时间戳</em>中保存了将记录改到当前值的事务的时间戳。</p><p>使用时间戳实现事务的隔离性时，往往都会使用乐观锁，先对数据进行修改，在写回时再去判断当前值，也就是时间戳是否改变过，如果没有改变过，就写入，否则，生成一个新的时间戳并再次更新数据，乐观锁其实并不是真正的锁机制，它只是一种思想，在这里并不会对它进行展开介绍。</p><h4 id="多版本和快照隔离"><a href="#多版本和快照隔离" class="headerlink" title="多版本和快照隔离"></a>多版本和快照隔离</h4><p>通过维护多个版本的数据，<strong>数据库可以允许事务在数据被其他事务更新时对旧版本的数据进行读取</strong>，很多数据库都对这一机制进行了实现；因为所有的读操作不再需要等待写锁的释放，所以能够显著地提升读的性能，MySQL 和 PostgreSQL 都对这一机制进行自己的实现，也就是 MVCC，虽然各自实现的方式有所不同，MySQL 就通过文章中提到的回滚日志实现了 MVCC，<strong>保证事务并行执行时能够不等待互斥锁的释放直接获取数据</strong>。</p><hr><p>如果一个事务原子地在一个一致地数据库中独立运行，那么在它执行之后，数据库的状态一定是一致的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;mysql如何实现事务&lt;/p&gt;</summary>
    
    
    
    <category term="Tech" scheme="http://example.com/categories/Tech/"/>
    
    
    <category term="Mysql" scheme="http://example.com/tags/Mysql/"/>
    
  </entry>
  
</feed>
