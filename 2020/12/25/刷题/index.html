<!DOCTYPE html>
<html lang="en">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="Leetcode 题型总结"/><link rel="alternate" href="/atom.xml" title="Stone's Blog" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.2" />
<link rel="canonical" href="http://example.com/2020/12/25/刷题/"/>

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.2" />

<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null,"server_url":null,"cdn":null},"toc":true,"fancybox":true,"pjax":"","latex":false};
</script>

    <title>Leetcode 题型总结 - Stone's Blog</title>
  <meta name="generator" content="Hexo 5.2.0"></head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Stone's Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">Home
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Stone's Blog</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            Home
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">Leetcode 题型总结
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-12-25
        </span></div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#Leetcode3-%E6%97%A0%E9%87%8D%E5%A4%8D%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="toc-text">Leetcode3 无重复的最长子串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LEETCODE25-K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-text">LEETCODE25.K个一组翻转链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LEETCODE15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-text">LEETCODE15.三数之和</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LEETCODE42-%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="toc-text">LEETCODE42.接雨水</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LEETCODE415-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0"><span class="toc-text">LEETCODE415.字符串相加</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LEETCODE103-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="toc-text">LEETCODE103.二叉树的锯齿层次遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LEETCODE-121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="toc-text">LEETCODE.121 买卖股票的最佳时机</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Leetcode124-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-text">Leetcode124.二叉树的最大路径和</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LEECODE31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97"><span class="toc-text">LEECODE31.下一个排列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LEETCODE143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8"><span class="toc-text">LEETCODE143.重排链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LEETCODE105-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">LEETCODE105.重建二叉树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LEETCODE206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-text">LEETCODE206.反转链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LEETCODE1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-text">LEETCODE1.两数之和</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LEETCODE199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE"><span class="toc-text">LEETCODE199.二叉树的右视图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LEETCODE215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0-%E5%8E%9F%E6%9D%A5%E8%BF%99%E5%B0%B1%E6%98%AFtopK"><span class="toc-text">LEETCODE215.数组中第K个最大元素 原来这就是topK</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LEETCODE232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-text">LEETCODE232.用栈实现队列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LEETCODE-146-LRU"><span class="toc-text">LEETCODE 146.LRU</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LEETCODE53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C"><span class="toc-text">LEETCODE53.最大子序和</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LEETCODE155-%E6%9C%80%E5%B0%8F%E6%A0%88"><span class="toc-text">LEETCODE155.最小栈</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LEETCODE20-%E6%9C%89%E6%95%88%E7%9A%84%E6%89%A9%E5%8F%B7"><span class="toc-text">LEETCODE20.有效的扩号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LEETCODE141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="toc-text">LEETCODE141.环形链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LEETCODE105-%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">LEETCODE105.前序与中序重建二叉树</span></a></li></ol>
    </div>
  </div><div class="post-content"><p>总结</p>
<a id="more"></a> 

<p>[toc]</p>
<p><a target="_blank" rel="noopener" href="https://img-blog.csdnimg.cn/2020121721064966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzdG9uZTE=,size_16,color_FFFFFF,t_70">https://img-blog.csdnimg.cn/2020121721064966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzdG9uZTE=,size_16,color_FFFFFF,t_70</a></p>
<h5 id="Leetcode3-无重复的最长子串"><a href="#Leetcode3-无重复的最长子串" class="headerlink" title="Leetcode3 无重复的最长子串"></a>Leetcode3 无重复的最长子串</h5><blockquote>
<p>这几天也写了好多遍了。发现用typora写题还行。一本质上抑制了看题解的冲动。二还可以这碎碎念..</p>
</blockquote>
<p>就是python缩进太蛋疼了</p>
<blockquote>
<p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
</blockquote>
<p>大体思路:滑动窗口双指针,当然还可以用哈希表优化优化，有点懒得搞。还是搞搞吧。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s)==<span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        left=right=<span class="number">0</span></span><br><span class="line">        ans = <span class="built_in">float</span>(-inf)</span><br><span class="line">        <span class="keyword">while</span> right !=<span class="built_in">len</span>(s)-<span class="number">1</span>:</span><br><span class="line">            <span class="comment"># </span></span><br><span class="line">            right+=<span class="number">1</span></span><br><span class="line">            <span class="comment"># 收缩</span></span><br><span class="line">            <span class="keyword">while</span> s[right] <span class="keyword">in</span> s[left:right]:</span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">            ans =<span class="built_in">max</span>(ans,right-left+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:<span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s)==<span class="number">1</span>:<span class="keyword">return</span> <span class="number">1</span> </span><br><span class="line">        left=right =<span class="number">0</span></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        window=&#123;&#125;</span><br><span class="line">        <span class="keyword">while</span> right!=<span class="built_in">len</span>(s):</span><br><span class="line">            c=s[right]</span><br><span class="line">            right+=<span class="number">1</span></span><br><span class="line">            window[c]=window.get(c,<span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> window[c]&gt;<span class="number">1</span>:</span><br><span class="line">                d = s[left]</span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">                window[d]-=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            ret= <span class="built_in">max</span>(ret,right-left)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<p>好像也没优化到哪去，反而代码还复杂了…</p>
<h5 id="LEETCODE25-K个一组翻转链表"><a href="#LEETCODE25-K个一组翻转链表" class="headerlink" title="LEETCODE25.K个一组翻转链表"></a>LEETCODE25.K个一组翻转链表</h5><p>有时间再写吧…</p>
<p>重写 已经忘的差不多了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums: [<span class="built_in">int</span>]</span>) -&gt; [[<span class="built_in">int</span>]]:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        res, k = [], <span class="number">0</span></span><br><span class="line">        <span class="comment"># 操作都在循环里面</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]: <span class="keyword">continue</span></span><br><span class="line">            j, k = i + <span class="number">1</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; k:</span><br><span class="line">                s = nums[i] + nums[j] + nums[k]</span><br><span class="line">                <span class="keyword">if</span> s &lt; <span class="number">0</span>:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[j] == nums[j - <span class="number">1</span>]: j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> s &gt; <span class="number">0</span>:</span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[k] == nums[k + <span class="number">1</span>]: k -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append([nums[k], nums[i], nums[j]])</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[j] == nums[j - <span class="number">1</span>]: j += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[k] == nums[k + <span class="number">1</span>]: k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>





<h5 id="LEETCODE15-三数之和"><a href="#LEETCODE15-三数之和" class="headerlink" title="LEETCODE15.三数之和"></a>LEETCODE15.三数之和</h5><blockquote>
<p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p>
</blockquote>
<p>大体思路就是先排个序 然后一个for循环 接双指针 麻烦点在于不重复 还有可以跳过的情况</p>
<p>去重的问题忘了咋解决了.. 去重的代码有四处，太逆天了…</p>
<p>后面的代码倒也能够理解 。看一看与下面一个值是否相同，相同直接跳</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums: [<span class="built_in">int</span>]</span>) -&gt; [[<span class="built_in">int</span>]]:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        res, k = [], <span class="number">0</span></span><br><span class="line">        <span class="comment"># 操作都在循环里面</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]: <span class="keyword">continue</span></span><br><span class="line">            j, k = i + <span class="number">1</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; k:</span><br><span class="line">                s = nums[i] + nums[j] + nums[k]</span><br><span class="line">                <span class="keyword">if</span> s &lt; <span class="number">0</span>:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[j] == nums[j - <span class="number">1</span>]: j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> s &gt; <span class="number">0</span>:</span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[k] == nums[k + <span class="number">1</span>]: k -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append([nums[k], nums[i], nums[j]])</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[j] == nums[j - <span class="number">1</span>]: j += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[k] == nums[k + <span class="number">1</span>]: k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">      </span><br><span class="line">     </span><br></pre></td></tr></table></figure>

<p>果然还是要自己写一遍 自己写一遍就发现错误百出</p>
<h5 id="LEETCODE42-接雨水"><a href="#LEETCODE42-接雨水" class="headerlink" title="LEETCODE42.接雨水"></a>LEETCODE42.接雨水</h5><blockquote>
<p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
</blockquote>
<p>经典题目。思路就是按列遍历 左边找最高的，左边找最高的 如果低于当前高度。那么这一格就集不到水。然后又根据木桶效应。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">      ans=<span class="number">0</span></span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(height)-<span class="number">1</span>):</span><br><span class="line">          left_max=<span class="built_in">max</span>(height[:i])</span><br><span class="line">          right_max=<span class="built_in">max</span>(height[i+<span class="number">1</span>:])</span><br><span class="line">          <span class="keyword">if</span> left_max&lt;height[i] <span class="keyword">or</span> right_max&lt;height[i]:<span class="keyword">continue</span></span><br><span class="line">          ans += <span class="built_in">min</span>(left_max,right_max)</span><br><span class="line">      <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>这么看这代码满打满算才10行</p>
<h5 id="LEETCODE415-字符串相加"><a href="#LEETCODE415-字符串相加" class="headerlink" title="LEETCODE415.字符串相加"></a>LEETCODE415.字符串相加</h5><p>给定两个字符串形式的非负整数 <code>num1</code> 和<code>num2</code> ，计算它们的和。</p>
<ol>
<li><strong>你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式</strong></li>
</ol>
<p>但是可以int()其中的字符..</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addStrings</span>(<span class="params">self, num1: <span class="built_in">str</span>, num2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        i=<span class="built_in">len</span>(num1)-<span class="number">1</span></span><br><span class="line">        j=<span class="built_in">len</span>(num2)-<span class="number">1</span></span><br><span class="line">        carry=<span class="number">0</span></span><br><span class="line">        ans=<span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> i&gt;=<span class="number">0</span> <span class="keyword">or</span> j&gt;=<span class="number">0</span>:</span><br><span class="line">            n1 = <span class="built_in">int</span>(num1[i]) <span class="keyword">if</span> i&gt;=<span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            n2 = <span class="built_in">int</span>(num2[j]) <span class="keyword">if</span> j&gt;=<span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            tmp = n1+n2+carry</span><br><span class="line">            carry = tmp//<span class="number">10</span></span><br><span class="line">            ans = <span class="built_in">str</span>(tmp%<span class="number">10</span>)+ans</span><br><span class="line">            i-=<span class="number">1</span></span><br><span class="line">            j-=<span class="number">1</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>+ ans <span class="keyword">if</span> carry <span class="keyword">else</span> ans</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<p>这题还挺有意思的</p>
<h5 id="LEETCODE103-二叉树的锯齿层次遍历"><a href="#LEETCODE103-二叉树的锯齿层次遍历" class="headerlink" title="LEETCODE103.二叉树的锯齿层次遍历"></a>LEETCODE103.二叉树的锯齿层次遍历</h5><blockquote>
<p>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
</blockquote>
<p>大体思路:</p>
<p>先完成层次遍历再加一个flag?</p>
<p>flag只控制加入temp_list的顺序…跟我理解的题意不太一样。其实这样感觉可以逆转一下也一样的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    def zigzagLevelOrder(self, root: TreeNode) -&gt; List[List[int]]:</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> []</span><br><span class="line">        flag=<span class="number">1</span></span><br><span class="line">        temp = collections.<span class="built_in">deque</span>()</span><br><span class="line">        temp.<span class="built_in">append</span>(root)</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(temp)!=<span class="number">0</span>:</span><br><span class="line">            n = <span class="built_in">len</span>(temp)</span><br><span class="line">            temp_list=collections.<span class="built_in">deque</span>()</span><br><span class="line">            <span class="keyword">for</span> i in <span class="built_in">range</span>(n):</span><br><span class="line">                node = temp.<span class="built_in">popleft</span>()</span><br><span class="line">                <span class="comment">//就记住这个flag就行</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="keyword">if</span> flag==<span class="number">1</span>:</span><br><span class="line">                    temp_list.<span class="built_in">append</span>(node.val)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    temp_list.<span class="built_in">appendleft</span>(node.val)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> node.left!=None:temp.<span class="built_in">append</span>(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right!=None:temp.<span class="built_in">append</span>(node.right)            </span><br><span class="line"></span><br><span class="line">            flag=(<span class="number">-1</span>)*flag</span><br><span class="line">            ans.<span class="built_in">append</span>(<span class="built_in">list</span>(temp_list))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="LEETCODE-121-买卖股票的最佳时机"><a href="#LEETCODE-121-买卖股票的最佳时机" class="headerlink" title="LEETCODE.121 买卖股票的最佳时机"></a>LEETCODE.121 买卖股票的最佳时机</h5><blockquote>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意：你不能在买入股票前卖出股票。</p>
</blockquote>
<p>这题是真的经典 覃超这个讲的真的挺明白的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        dp=[[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 0代表手上没有股票 1代码手上有股票 2代码卖出股票</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=-price[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>]=<span class="number">0</span></span><br><span class="line">       	ans =<span class="number">0</span> </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">        	dp[i][<span class="number">0</span>]=dp[i-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">          dp[i][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]-price[i])</span><br><span class="line">          dp[i][<span class="number">2</span>]=dp[i-<span class="number">1</span>][<span class="number">1</span>]+price[i]</span><br><span class="line">          ans = <span class="built_in">max</span>(ans,dp[i][<span class="number">0</span>],dp[i][<span class="number">1</span>],dp[i][<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="Leetcode124-二叉树的最大路径和"><a href="#Leetcode124-二叉树的最大路径和" class="headerlink" title="Leetcode124.二叉树的最大路径和"></a>Leetcode124.二叉树的最大路径和</h5><blockquote>
<p> 给定一个非空二叉树，返回其最大路径和。本题中，路径被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</p>
</blockquote>
<p>不是很能理解</p>
<p>好像大概又能理解了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.maxSum = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPathSum</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">   			<span class="function"><span class="keyword">def</span> <span class="title">maxGain</span>(<span class="params">node</span>)-&gt;<span class="built_in">int</span>:</span></span><br><span class="line">      		<span class="keyword">if</span> <span class="keyword">not</span> node:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">          </span><br><span class="line">          left=<span class="built_in">max</span>(<span class="number">0</span>,maxGain(root.left))</span><br><span class="line">          right=<span class="built_in">max</span>(<span class="number">0</span>,maxGain(root.right))</span><br><span class="line">          </span><br><span class="line">					priceNew = root.val +left + right</span><br><span class="line">          self.maxSum=<span class="built_in">max</span>(self.maxSum,spriceNew</span><br><span class="line">       	</span><br><span class="line">        <span class="keyword">return</span> node.val+<span class="built_in">max</span>(left,right)</span><br><span class="line">        </span><br><span class="line">        maxGain(root)</span><br><span class="line">        <span class="keyword">return</span> self.maxSum</span><br></pre></td></tr></table></figure>

<h5 id="LEECODE31-下一个排列"><a href="#LEECODE31-下一个排列" class="headerlink" title="LEECODE31.下一个排列"></a>LEECODE31.下一个排列</h5><blockquote>
<p>实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p>
<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>
<p>必须 原地 修改，只允许使用额外常数空间。</p>
</blockquote>
<p>今天想办法搞定。</p>
<p>先试着理解题意吧。举几个例子看看。</p>
<p>1-&gt;2-&gt;4-&gt;5,这一段是升序的，也就是5421已经是最大数，不存在比它大的组合，</p>
<p>递增这样的就是字典序最大 。因为啥呢。反正就是和真实大小相反。</p>
<p>这个题目本身不难，关键是理解题意，我们以一个例子来分析，给定325421，求其下一个比它大的数，怎么办呢？我们应该从最低位开始，1-&gt;2-&gt;4-&gt;5,这一段是升序的，也就是5421已经是最大数，不存在比它大的组合，我们继续找，1-&gt;2-&gt;4-&gt;5-&gt;2，出现降序这个位置就是我们要找的关键点，只需要将2与其后的数字中的（1,2,4,5）<strong>比它大的最小数</strong>，也就4替换，<strong>然后再将后面的数</strong>（1,2,2,5）升序排列便可得到下一个数，过程为：325421-&gt;345221-&gt;345122</p>
<p>找反向遍历第一个降序点 2 之后的数字</p>
<p>从后往前找到比一个数字大的数</p>
<p>找到后和后面比它大的最小数交换</p>
<p>换完后排序</p>
<p>这样就清晰多了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> keyIndex=nums.<span class="built_in">size</span>()<span class="number">-1</span>;<span class="comment">//指向最后一个数</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//比前一个数字大</span></span><br><span class="line">		<span class="keyword">while</span>(keyIndex&gt;<span class="number">0</span>&amp;&amp;nums.<span class="built_in">at</span>(keyIndex)&lt;=nums.<span class="built_in">at</span>(keyIndex<span class="number">-1</span>))</span><br><span class="line">			keyIndex--;<span class="comment">//寻找降序关键点</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span>(keyIndex==<span class="number">0</span>)<span class="comment">//如果关键点下标为0，则原数据排列为全降序，不存在比它更大的数，将原排列升序重排</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>())</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> minNum=nums[keyIndex<span class="number">-1</span>];<span class="comment">//关键点下标对应的待替换数字</span></span><br><span class="line">      <span class="comment">//因为是升序所以直接找</span></span><br><span class="line">      <span class="comment">//找到比它最大最小那个 对那的确就是反向找</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=nums.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;keyIndex<span class="number">-1</span>;i--)<span class="comment">//寻找关键点后最小的且大于待替换数字的数据对应的下标</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(nums[i]&gt;minNum)<span class="comment">//找到，则替换</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">int</span> temp;</span><br><span class="line">					temp=nums[i];</span><br><span class="line">					nums[i]=nums[keyIndex<span class="number">-1</span>];</span><br><span class="line">					nums[keyIndex<span class="number">-1</span>]=temp;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>()+keyIndex,nums.<span class="built_in">end</span>());<span class="comment">//将替换后，关键点后的数据进行升序重排</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">看题解都看的不是很明白 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="LEETCODE143-重排链表"><a href="#LEETCODE143-重排链表" class="headerlink" title="LEETCODE143.重排链表"></a>LEETCODE143.重排链表</h5><blockquote>
<p>给定一个单链表 L：L0→L1→…→Ln-1→Ln ，<br>将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
</blockquote>
<p>这题挺有意思的。</p>
<p>两个思路 一个是像这样的用数组存</p>
<p>第二个是 找中点 + 反转 后半部分 + merge </p>
<p>显然前一个比后一个简单太多了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reorderList</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify head in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:<span class="keyword">return</span> head</span><br><span class="line">        vec=[]</span><br><span class="line">        cur =head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            vec.append(cur)</span><br><span class="line">            cur=cur.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        j=<span class="built_in">len</span>(vec)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;j:</span><br><span class="line">            vec[i].<span class="built_in">next</span>=vec[j]</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i==j:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            vec[j].<span class="built_in">next</span>=vec[i]</span><br><span class="line">            j-=<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        vec[j].<span class="built_in">next</span>=<span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>

<hr>
<p>第一次面试的题 现在才解出来。那时候的确没法写出回溯来。</p>
<blockquote>
<p>给定一个int数组A，给定一个数x，求所有求和能得到x的数字组合，组合中的元素来自A</p>
</blockquote>
<p>解回溯的题 感觉最重要的是遍历 只要我能遍历到所有的tmp 那么就一定能找到答案。</p>
<p>然后再加上一些剪枝。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">		self.res=[]</span><br><span class="line">		self.tmp=[]</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">getSetOfSum</span>(<span class="params">self,nums:<span class="type">List</span>[<span class="built_in">int</span>],target</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> nums:<span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">recur</span>(<span class="params">nums:<span class="type">List</span>[<span class="built_in">int</span>],target:<span class="built_in">int</span>,index:<span class="built_in">int</span></span>):</span></span><br><span class="line">			<span class="keyword">if</span> target&lt;<span class="number">0</span>:</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> target==<span class="number">0</span>:</span><br><span class="line">				self.res.append(self.tmp[:])</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index,<span class="built_in">len</span>(nums)-<span class="number">1</span>):</span><br><span class="line">				self.tmp.append(nums[i])</span><br><span class="line">				recur(nums,target-nums[i],i)</span><br><span class="line">				self.tmp.pop()</span><br><span class="line"></span><br><span class="line">		recur(nums,target,<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	a = Solution()</span><br><span class="line">	result = a.getSetOfSum([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],<span class="number">6</span>)</span><br><span class="line">	<span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="LEETCODE105-重建二叉树"><a href="#LEETCODE105-重建二叉树" class="headerlink" title="LEETCODE105.重建二叉树"></a>LEETCODE105.重建二叉树</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Create</span>(<span class="number">0</span>,preorder.<span class="built_in">size</span>()<span class="number">-1</span>,<span class="number">0</span>,inorder.<span class="built_in">size</span>()<span class="number">-1</span>,preorder,inorder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先序 根左右</span></span><br><span class="line">    <span class="comment">// 中序 左根右</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">Create</span><span class="params">(<span class="keyword">int</span> preL,<span class="keyword">int</span> preR,<span class="keyword">int</span> inL,<span class="keyword">int</span> inR,vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preL&gt;preR)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        TreeNode * root =<span class="keyword">new</span> TreeNode;</span><br><span class="line">        root-&gt;val=preorder[preL];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//先序的第一个就是根节点 保留根节点</span></span><br><span class="line">        <span class="comment">//想一想后序怎么写好吧</span></span><br><span class="line">        <span class="comment">//左右根</span></span><br><span class="line">        <span class="comment">//左根右</span></span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;<span class="comment">//保存根节点在中序里的下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =inL;i&lt;=inR;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;val==inorder[i])&#123;</span><br><span class="line">                k=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左子树长度</span></span><br><span class="line">        <span class="keyword">int</span> left_tree_length = k-inL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//思路还是很清晰的 之前一直没绕过这个弯</span></span><br><span class="line">        root-&gt;left = <span class="built_in">Create</span>(preL+<span class="number">1</span>,preL+left_tree_length,inL,k<span class="number">-1</span>,preorder,inorder);</span><br><span class="line">        root-&gt;right = <span class="built_in">Create</span>(preL+left_tree_length+<span class="number">1</span>,preR,k+<span class="number">1</span>,inR,preorder,inorder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>果然代码要自己写一遍才是自己的。</p>
<p>边界问题还是挺多问题的。</p>
<p>1.preL+k–inL 2.还有size()-1 3.还有Treenode *root = new TreeNode</p>
<p>踩了三个坑。</p>
<hr>
<p>move on move on</p>
<hr>
<h5 id="LEETCODE206-反转链表"><a href="#LEETCODE206-反转链表" class="headerlink" title="LEETCODE206.反转链表"></a>LEETCODE206.反转链表</h5><p>直接条件反射</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">     		<span class="keyword">if</span> <span class="keyword">not</span> head:<span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        prev=<span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">          next_p=head.<span class="built_in">next</span></span><br><span class="line">          <span class="comment"># 条件反射还是能写出bug</span></span><br><span class="line">          </span><br><span class="line">          head.<span class="built_in">next</span>=prev</span><br><span class="line">          </span><br><span class="line">          prev=head</span><br><span class="line">          head=next_p</span><br><span class="line">       <span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure>

<h5 id="LEETCODE1-两数之和"><a href="#LEETCODE1-两数之和" class="headerlink" title="LEETCODE1.两数之和"></a>LEETCODE1.两数之和</h5><p>写了这么多遍还是容易忘</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">  <span class="comment"># key 是num value 是index</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    		hashtable=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> index,value <span class="keyword">in</span> emumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> target-value <span class="keyword">in</span> hashtable:</span><br><span class="line">              	<span class="keyword">return</span> [index,hashtable[target-num]]</span><br><span class="line">            hashtable[value]=index</span><br><span class="line">       <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>

<h5 id="LEETCODE199-二叉树的右视图"><a href="#LEETCODE199-二叉树的右视图" class="headerlink" title="LEETCODE199.二叉树的右视图"></a>LEETCODE199.二叉树的右视图</h5><blockquote>
<p>最近才写的应该</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">      <span class="comment">#懒得写了...</span></span><br><span class="line">      	<span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> []</span><br><span class="line">        ans=[]</span><br><span class="line">        <span class="comment">#ans.append(root.val)</span></span><br><span class="line">        queue=[root]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">          n = <span class="built_in">len</span>(queue)</span><br><span class="line">          ans.append(queue[-<span class="number">1</span>].val)</span><br><span class="line">          <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,n):</span><br><span class="line">             node = queue.pop()</span><br><span class="line">             <span class="keyword">if</span> root.left:queue.append(root.left)</span><br><span class="line">             <span class="keyword">if</span> root.right:queue.append(root.right)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<p>LEETCODE160.相交链表</p>
<blockquote>
<p> 编写一个程序，找到两个单链表相交的起始节点。</p>
</blockquote>
<p>这题挺有意思的。题解太好玩了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        l1 =headA</span><br><span class="line">        L2 =headB</span><br><span class="line">        <span class="keyword">while</span> l1!=l2:</span><br><span class="line">          <span class="comment"># 相当于第一条路走到头了.</span></span><br><span class="line">           <span class="keyword">if</span> l1==<span class="literal">None</span>:</span><br><span class="line">                l1=headB</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l1=l1.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> l2==<span class="literal">None</span>:</span><br><span class="line">                l2=headA</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l2=l2.<span class="built_in">next</span>     </span><br><span class="line">        <span class="keyword">return</span> l1</span><br></pre></td></tr></table></figure>

<h5 id="LEETCODE215-数组中第K个最大元素-原来这就是topK"><a href="#LEETCODE215-数组中第K个最大元素-原来这就是topK" class="headerlink" title="LEETCODE215.数组中第K个最大元素 原来这就是topK"></a>LEETCODE215.数组中第K个最大元素 原来这就是topK</h5><blockquote>
<p>在未排序的数组中找到第 <strong>k</strong> 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
</blockquote>
<p>大体思路:直接奔着题解去了~方法一：基于快速排序的选择方法 方法二：基于堆排序的选择方法</p>
<p>所以这个题目 排个序就完了</p>
<p>堆排 然后调用K次？建堆 然后调用K次 </p>
<p>今天下午尽量就是解决堆排和快排的问题</p>
<p>堆的话就是大顶堆</p>
<p>我有点不太清楚大顶堆和二叉树搜索树区别</p>
<p>大顶堆只能保证根是最大的？但是不保证左右。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp= arr[i];</span><br><span class="line">	arr[i]=arr[j];</span><br><span class="line">	arr[j]=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span> tree[],<span class="keyword">int</span> n,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i&gt;=n)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> c1 = <span class="number">2</span>*i +<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> c2 = <span class="number">2</span>*i +<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> maxIndex=i;</span><br><span class="line">	<span class="keyword">if</span> (c1&lt; n &amp;&amp; tree[c1]&gt;tree[maxIndex])&#123;</span><br><span class="line">		maxIndex =c1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (c2&lt; n &amp;&amp; tree[c2]&gt;tree[maxIndex])&#123;</span><br><span class="line">		maxIndex =c2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (maxIndex!=i)&#123;</span><br><span class="line">		swap(tree,maxIndex,i);</span><br><span class="line">		heapify(tree,n,maxIndex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_heap</span><span class="params">(<span class="keyword">int</span> tree[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> last_node=n<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> parent=(last_node<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i=parent;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		heapify(tree,n,i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="keyword">int</span> tree[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	build_heap(tree,n);</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		swap(tree,i,<span class="number">0</span>);</span><br><span class="line">		heapify(tree,i,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//大的被交换到尾巴去了 太有意思了堆排</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    heap_sort(nums,numsSize);</span><br><span class="line">    <span class="keyword">return</span> nums[numsSize-k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是快排</p>
<p>先回忆一下快排 两个哨兵找 然后交换 一直到相遇 相遇了就可以再交换。找到temp的位置了说明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = left, j = right, temp = arr[left], t;</span><br><span class="line">        <span class="keyword">while</span> (i != j) &#123;</span><br><span class="line">          	<span class="comment">// 右边找到一个比base小的</span></span><br><span class="line">            <span class="keyword">while</span> (arr[j] &gt;= temp &amp;&amp; i &lt; j) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="comment">// 左边找到一个比base大的</span></span><br><span class="line">            <span class="keyword">while</span> (arr[i] &lt;= temp &amp;&amp; i&lt;j) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="comment">//交换</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                t = arr[i];</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                arr[j] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  			<span class="comment">//base交换</span></span><br><span class="line">  			<span class="comment">//然后递归下去</span></span><br><span class="line">        arr[left] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">        sort(arr, left, i - <span class="number">1</span>);</span><br><span class="line">        sort(arr, i+<span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>太骚了 这个快排</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span>(<span class="params"><span class="built_in">list</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">list</span>)&lt;<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        midpivot = <span class="built_in">list</span>[<span class="number">0</span>]</span><br><span class="line">        lessbeforemidpivot = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>[<span class="number">1</span>:] <span class="keyword">if</span> i&lt;=midpivot]</span><br><span class="line">        biggerafterpivot = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>[<span class="number">1</span>:] <span class="keyword">if</span> i &gt; midpivot]</span><br><span class="line">        finallylist = quicksort(lessbeforemidpivot)+[midpivot]+quicksort(biggerafterpivot)</span><br><span class="line">        <span class="keyword">return</span> finallylist</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> quicksort([<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>])</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="LEETCODE232-用栈实现队列"><a href="#LEETCODE232-用栈实现队列" class="headerlink" title="LEETCODE232.用栈实现队列"></a>LEETCODE232.用栈实现队列</h5><p>old friend 思路清晰就行        </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s2;</span><br><span class="line">    <span class="built_in">CQueue</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        s1.<span class="built_in">push</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//# 思路没问题的</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="comment">//# s2非空</span></span><br><span class="line">      <span class="keyword">if</span>(s2.<span class="built_in">size</span>()!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp= s2.<span class="built_in">top</span>();</span><br><span class="line">      	s2.<span class="built_in">pop</span>();</span><br><span class="line">      	<span class="keyword">return</span> temp;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//# s2 s1 为空</span></span><br><span class="line">      <span class="keyword">if</span> (s1.<span class="built_in">size</span>()==<span class="number">0</span> <span class="keyword">and</span> s2.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      <span class="comment">//# # s1非空 s2为空</span></span><br><span class="line">      <span class="keyword">while</span> (!s1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        s2.<span class="built_in">push</span>(s1.<span class="built_in">top</span>());</span><br><span class="line">        s1.<span class="built_in">pop</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> ans =s2.<span class="built_in">top</span>();</span><br><span class="line">      s2.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CQueue* obj = new CQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;appendTail(value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;deleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h5 id="LEETCODE-146-LRU"><a href="#LEETCODE-146-LRU" class="headerlink" title="LEETCODE 146.LRU"></a>LEETCODE 146.LRU</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DLinkListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,key=<span class="number">0</span>,value=<span class="number">0</span></span>):</span></span><br><span class="line">        self.key=key</span><br><span class="line">        self.value=value</span><br><span class="line">        self.prev=<span class="literal">None</span></span><br><span class="line">        self.<span class="built_in">next</span>=<span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.cache=<span class="built_in">dict</span>()</span><br><span class="line">        <span class="comment"># 伪头伪尾</span></span><br><span class="line">        self.tail=DLinkListNode()</span><br><span class="line">        self.head=DLinkListNode()</span><br><span class="line">        self.head.<span class="built_in">next</span>=self.tail</span><br><span class="line">        self.tail.prev=self.head</span><br><span class="line">        self.capacity=capacity</span><br><span class="line">        self.size=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.cache:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        node = self.cache[key]</span><br><span class="line">        self.moveToHead(node)</span><br><span class="line">        <span class="keyword">return</span> node.value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.cache:</span><br><span class="line">            <span class="comment"># 初始化</span></span><br><span class="line">            node = DLinkListNode(key,value)</span><br><span class="line">            self.cache[key]=node</span><br><span class="line">            self.addToHead(node)</span><br><span class="line">            self.size+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.size&gt;self.capacity:</span><br><span class="line">                removed = self.removeTail()</span><br><span class="line">                <span class="comment">#pop</span></span><br><span class="line">                self.cache.pop(removed.key)</span><br><span class="line">                self.size-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node=self.cache[key]</span><br><span class="line">            node.value=value</span><br><span class="line">            self.moveToHead(node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addToHead</span>(<span class="params">self,node</span>):</span></span><br><span class="line">        <span class="comment"># o-&gt;o o-&gt;N-&gt;o</span></span><br><span class="line">        head_next = self.head.<span class="built_in">next</span></span><br><span class="line">        node.prev=self.head</span><br><span class="line">        node.<span class="built_in">next</span>=head_next</span><br><span class="line">        head_next.prev=node</span><br><span class="line">        self.head.<span class="built_in">next</span>=node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNode</span>(<span class="params">self,node</span>):</span></span><br><span class="line">        node.prev.<span class="built_in">next</span>=node.<span class="built_in">next</span></span><br><span class="line">        node.<span class="built_in">next</span>.prev=node.prev</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveToHead</span>(<span class="params">self,node</span>):</span></span><br><span class="line">        self.removeNode(node)</span><br><span class="line">        self.addToHead(node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeTail</span>(<span class="params">self</span>):</span></span><br><span class="line">        node = self.tail.prev</span><br><span class="line">        self.removeNode(node)</span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure>

<h5 id="LEETCODE53-最大子序和"><a href="#LEETCODE53-最大子序和" class="headerlink" title="LEETCODE53.最大子序和"></a>LEETCODE53.最大子序和</h5><blockquote>
<p> 给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
</blockquote>
<p>别说这道题要是冷不丁一来我还真接不住</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    def maxSubArray(self, nums: List[int]) -&gt; int:</span><br><span class="line">        maxSum = nums[<span class="number">0</span>]</span><br><span class="line">        curSum =nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">            curSum = <span class="built_in">max</span>(curSum+nums[i],nums[i])</span><br><span class="line">            maxSum=<span class="built_in">max</span>(maxSum,curSum)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxSum</span><br></pre></td></tr></table></figure>

<h5 id="LEETCODE155-最小栈"><a href="#LEETCODE155-最小栈" class="headerlink" title="LEETCODE155.最小栈"></a>LEETCODE155.最小栈</h5><blockquote>
<p>这个解法也挺巧妙的 。</p>
</blockquote>
<p>大体思路:之前一直扣细节。其实只要每次push 的时候栈顶和当前push一个最小的进去就行。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.min_stack = [math.inf]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.stack.append(x)</span><br><span class="line">        <span class="comment"># 就这一句</span></span><br><span class="line">        self.min_stack.append(<span class="built_in">min</span>(x, self.min_stack[-<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.stack.pop()</span><br><span class="line">        self.min_stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.min_stack[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h5 id="LEETCODE20-有效的扩号"><a href="#LEETCODE20-有效的扩号" class="headerlink" title="LEETCODE20.有效的扩号"></a>LEETCODE20.有效的扩号</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        pairs = &#123;</span><br><span class="line">            <span class="string">&quot;)&quot;</span>: <span class="string">&quot;(&quot;</span>,</span><br><span class="line">            <span class="string">&quot;]&quot;</span>: <span class="string">&quot;[&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&#125;&quot;</span>: <span class="string">&quot;&#123;&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        stack = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> ch <span class="keyword">in</span> pairs:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">or</span> stack[-<span class="number">1</span>] != pairs[ch]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(ch)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> stack</span><br></pre></td></tr></table></figure>

<h5 id="LEETCODE141-环形链表"><a href="#LEETCODE141-环形链表" class="headerlink" title="LEETCODE141.环形链表"></a>LEETCODE141.环形链表</h5><p>大体思路:快慢指针就行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        slow = fast =head</span><br><span class="line">        <span class="keyword">while</span> slow <span class="keyword">and</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> slow <span class="keyword">is</span> fast:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h5 id="LEETCODE105-前序与中序重建二叉树"><a href="#LEETCODE105-前序与中序重建二叉树" class="headerlink" title="LEETCODE105.前序与中序重建二叉树"></a>LEETCODE105.前序与中序重建二叉树</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Rebuild</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="keyword">int</span>&gt;&amp; inorder,<span class="keyword">int</span> preL,<span class="keyword">int</span> preR,<span class="keyword">int</span> inL,<span class="keyword">int</span> inR)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preL&gt;preR)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode * root = <span class="keyword">new</span> TreeNode;</span><br><span class="line">        root-&gt;val = preorder[preL];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=inL;i&lt;=inR;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;val ==inorder[i])&#123;</span><br><span class="line">                k=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftLen= k-inL;</span><br><span class="line"></span><br><span class="line">        root-&gt;left=<span class="built_in">Rebuild</span>(preorder,inorder,preL+<span class="number">1</span>,preL+leftLen,inL,k<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right=<span class="built_in">Rebuild</span>(preorder,inorder,preL+leftLen+<span class="number">1</span>,preR,k+<span class="number">1</span>,inR);   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Rebuild</span>(preorder,inorder,<span class="number">0</span>,preorder.<span class="built_in">size</span>()<span class="number">-1</span>,<span class="number">0</span>,inorder.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>LEETCODE300.最长上升子序列</p>
<blockquote>
<p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
</blockquote>
<p>dp题 你要我写 我不一定写的出来。就到这吧。留给明天写一写。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


      </div>
      <div class="post-copyright">
    <p class="copyright-item">
      <span>Author: </span>
      <a href="http://example.com">zstone12</a>
    </p>
    <p class="copyright-item">
      <span>Link: </span>
      <a href="http://example.com/2020/12/25/%E5%88%B7%E9%A2%98/">http://example.com/2020/12/25/%E5%88%B7%E9%A2%98/</a>
    </p>
    <p class="copyright-item">
      <span>License: </span><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>
      <footer class="post-footer">
        
        <nav class="post-nav"><a class="prev" href="/2020/12/28/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">LeetCode-股票问题</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    <a class="next" href="/2020/12/22/HTTP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84%E5%8F%8ATCP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84/">
        <span class="next-text nav-default">HTTP 报文结构及TCP 报文结构</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
        <a target="_blank" rel="noopener" href="https://github.com/ahonn" class="iconfont icon-github" title="github"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">&copy;2015 - 2023<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">zstone12</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.2"></script>
</body>
</html>
